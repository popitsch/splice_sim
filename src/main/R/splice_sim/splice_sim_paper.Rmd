---
title: "splice_sim_paper.Rmd"
author: "niko.popitsch@imba.oeaw.ac.at"
documentclass: article
fontsize: 10pt
output:
  html_document:
    df_print: paged
  pdf_document:
    fig_caption: yes
    fig_height: 10
    fig_width: 10
geometry: margin=1in
classoption: a4paper
params:
    splice_sim_config:
       value: "/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/splice_sim.config.json"
    out_dir:
       value: "/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/analysis/"
---
<style type="text/css">
body, td {
   font-size: 10px;
}
code.r{
  font-size: 10px;
}
pre {
  font-size: 10px
}
div.blue pre { background-color:lightblue; }
div.blue pre.r { background-color:blue; }
</style>

# INIT

```{r setup, include=FALSE}
require(data.table)
require(tidyr)
require(dplyr)
require(ggplot2)
require(scales)
require(rjson)
require(stringr)
require(VGAM)
require(cowplot)
require(arrow)
require(tictoc)
require(ggpubr)
require(minpack.lm)
require(readr)
require(testthat)
require(tidylog)
require(RColorBrewer)
# NB install arrow with snappy on Rstudio server
# Sys.setenv(ARROW_WITH_SNAPPY = "ON")
# Sys.setenv(NOT_CRAN="true")
# Sys.setenv(LIBARROW_BINARY="FALSE")
# install.packages("arrow", repos = "https://arrow-r-nightly.s3.amazonaws.com")

# to ensure stripping '\0' (nul) from character vector
options(arrow.skip_nul = TRUE)

# global theme
theme_set(theme_light())


# load data from TSV
load_table = function(dataF, append="", header=T, nrows=Inf) {
  dataF = as.character(paste0(dataF, append))
  print(paste("Loading", dataF))
  if ( endsWith(dataF, ".gz") ) {
    return(fread(cmd=paste('gunzip -c', dataF), header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  } else {
    return(fread(dataF, header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  }
}

# multiple plots with single title
my_plot_grid = function(plots, main, ncol=NULL, nrow=NULL, labels=NULL) {
  if (!is.null(labels) & labels==T) {
    labels=LETTERS[1:length(plots)]
  }
  plot_row=plot_grid(plotlist=plots, ncol=ncol, nrow=nrow, labels=labels)
  title <- ggdraw() + draw_label( main, fontface = 'bold', x = 0, hjust = 0 ) + theme(plot.margin = margin(0, 0, 0, 7))
  return (plot_grid(title, plot_row, ncol = 1, rel_heights = c(0.1, 1)))
}

# calculate confidence interval
# call with calc_ci( mtcars, mpg)
calc_ci = function(d, col, min_lower_ci=NA, max_upper_ci=NA) {
  ret = d %>% summarise(
            col.mean := mean({{col}}, na.rm = TRUE),
            col.median := median({{col}}, na.rm = TRUE),
            col.sd = sd({{col}}, na.rm = TRUE),
            col.n = n(),
            .groups = 'drop') %>%
  mutate(stderr = col.sd / sqrt(col.n),
         lower.ci = col.mean - qt(1 - (0.05 / 2), col.n - 1) * stderr,
         upper.ci = col.mean + qt(1 - (0.05 / 2), col.n - 1) * stderr) %>% 
  ungroup() %>% 
  mutate(lower.ci = pmax(min_lower_ci, lower.ci, na.rm=T),
         upper.ci = pmin(max_upper_ci, upper.ci, na.rm=T))
  return (ret)
}

calc_iqr = function(d, col) {
  d %>% summarise(
            col.median = median({{col}}, na.rm = T),
            col.mean = mean({{col}}, na.rm = T),
            col.upper = quantile({{col}}, .75, na.rm = T),
            col.lower = quantile({{col}}, .25, na.rm = T),
            col.n = n(),
            .groups = 'drop')
}

#
# write result tibble to BED file
#
write_bed = function(dat, bed_file, title, header=F) {
  sink(bed_file)
  cat(paste0("track name=",title," description=\"",title,"\" useScore=1 itemRgb=\"On\"\n"))
  sink()
  dat %>% write_tsv( bed_file, col_names = F, append = T ) 
}

# groups data and calculates performance and coverage
calc_performance=function(tab, grp, readlen) {
  tab %>% 
    group_by_at(vars(one_of(grp))) %>% 
    summarise(count=sum(count)) %>% 
    pivot_wider(names_from=classification, values_from=count, names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      read_count=TP+FN,
      cov=read_count*!!readlen/len,
      precision=ifelse(TP+FP>0, TP/(TP+FP), NA),
      recall=ifelse(TP+FN>0,TP/(TP+FN), NA),
      F1=ifelse((2*TP+FP+FN)>0,2*TP/(2*TP+FP+FN),NA)
  ) 
}

```


# data

```{r data, include=FALSE}

home_dir=paste0(dirname(params$splice_sim_config),'/')
conf=fromJSON(paste(readLines(params$splice_sim_config), collapse=""))

#home_dir='/Users/niko.popitsch/Desktop/data/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/'


# results files
data_file=paste0(home_dir,'/results/data.rds')
meta_file=paste0(home_dir,'/results/meta.rds')

if (file.exists(data_file)) {
  tic("load data")
  d=readRDS(data_file)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(meta_file)) {
  tic("load metadata")
  m=readRDS(meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}


# to calc performance data
# calc_performance(d[['fx']], 
                      # c('fid', 'mapper', 'conversion_rate', 'classification', 'len', 'gene_name', 'num_exons', 'ftype'),
                      # conf$readlen) 

# to add meta data
# %>% 
#   left_join(m[['tx']], by=c('fid'='tid')) %>% # NB too-short tx are lost
#   left_join(m[['ga']], by=c('fid'='tid')) 

```


## QC

### NA counts
Calculate and plot the fraction of NA counts per table/column
```{r}
# count non-NA values per column for all passed tables
count_na_per_column = function(tables) {
 counts=tibble()
 for (name in names(tables)) {
    tab=tables[[name]]
    nr=nrow(tab)
    print(nr)
    if (nr>0) {
      counts=counts %>% rbind(
        tab %>% select(everything()) %>% summarise_all(funs(sum(is.na(.)))) %>% mutate(table=!!name) %>% collect() %>% pivot_longer(-table) %>% mutate(nr=!!nr, frac=value/nr)
      )
    }
  }
  return (counts)
}

non_na_counts = count_na_per_column(c(setNames(d, paste0('d_',names(d))),setNames(m, paste0('m_',names(m)))) )
ggplot(non_na_counts, aes(x=name, y=frac)) +
  geom_bar(stat='identity') +
  facet_wrap(table~., scales = 'free') +
  ggtitle("Fraction of NA counts per table column") + 
  xlab("") + ylab("") +
  ylim(0,1) +
  coord_flip() 

```

### Missing tids

Some of the originally configured transcript ids are missing from result data. 
This is either because 
- there were no reads simulated as the annotation is smaller than read-size and there are no (longer) overlapping transcripts
- annotations are very long (e.g., Kcnip1 or Cmss1)
```{r}
found_tids=unique(d[['tx']] %>% pull(fid))
print(paste0("We have data for ", length(found_tids), '/', length(d[['tx']]), " transcripts"))

```


## Coverage

- The target coverage is ~50X per isoform, i.e., 100X overall
- There is an edge effect as reads that overlap with 1bp are counted for their full length when coverage is calculated.
  This could explain the increased mean coverage for exons and introns. 
  For exons this effect is a bit reduced as the 1st/last exon also has an edge effect as we don't simulate reads that overlap the tx edges.

<div class = "blue">
<b>Coverage of simulated/mapped reads per isoform/genomic feature.</b>
A) Coverage distributions calculated from unconverted reads only (conversion rate = 0). 
   Both mappers have problems with spliced read mapping indicated by reduced coverage of spliced reads (panel mat/exon)
   and increased coverage of mature isoform reads that were false-positively mapped to introns (panel mat/intron). 
   Presumably, most of these reads are overlapping the splice junctions.
B) Mean coverage per conversion rate. 
   STAR shows decreased coverage of spliced reads with increasing conversion rates while HISAT3N is unaffected by this.
Note that deviations of the configured ~100X coverage for this 1:1 mix of premature/mature isoforms presumably stems from edge effects of the coverage
calculation that does not take partial read overlap into account. Coverage thresholds 0,50,100 are indicated by grey horizontal lines.
</div>


```{r}
calc_coverage = function(grp_tab) {
  grp_tab %>% 
      summarise(count=sum(count)) %>% 
      pivot_wider(names_from=c(mapper,classification), values_from=count, names_sort=T) %>% 
      mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
      filter(len>conf$readlen) %>% # filter too-short introns as this will lead to wrong coverage calc. Example: ENSMUST00000116560.2_in5
      mutate(
        simulated=(HISAT3N_TP+HISAT3N_FN)*!!conf$readlen/len, # same as simulated_star!
        HISAT3N=(HISAT3N_TP+HISAT3N_FP)*!!conf$readlen/len,
        STAR=(STAR_TP+STAR_FP)*!!conf$readlen/len,
    ) %>% pivot_longer(c(simulated, HISAT3N, STAR), names_to='mapper') %>% 
    mutate(mapper=factor(mapper, levels=c('simulated', 'HISAT3N', 'STAR')),
           is_converted=ifelse(conversion_rate==0,'no conversions', 'converted reads')) %>% 
    ungroup()
}

hlines=tribble(
  ~y,  ~cat,
  0,   1,
  50,  2,
  100, 3
)
tx = d[['tx']] %>% left_join(m[['tx']], by=c('fid'='tid')) 
fx = d[['fx']] %>% left_join(m[['fx']], by='fid') 

p1 = calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  facet_grid(is_converted~., scales = 'free') +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage over tx interval') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification )) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p3 = calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, ftype, len, classification )) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p4 = calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, true_isoform, len, classification ) ) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per isoform') +
  facet_grid(is_converted~true_isoform, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

my_plot_grid(list(p1,p2,p3,p4), labels=T, 'QC: Coverage for converted and unconverted reads', nrow = 1)

# final

tab = calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification ))
p1 = tab %>% 
  filter(is_converted=='no conversions') %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = calc_ci(tab %>% group_by(conversion_rate, ftype, true_isoform, mapper), value) %>% 
  ggplot(aes(x=conversion_rate, y=col.mean, col=mapper, group=mapper)) + 
  geom_ribbon(aes(ymin=lower.ci, ymax=upper.ci), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean coverage per condition') +
  facet_grid(.~true_isoform+ftype)

my_plot_grid(list(p1,p2), labels=T, 'Coverage per mapper', nrow = 1)


# calc_coverage(d[['tx']] %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% group_by(conversion_rate,mapper) %>% summarise(m=mean(value)) %>% ggplot(aes(conversion_rate,m,fill=mapper)) + geom_bar(stat='identity', position = 'dodge') + ggtitle('Mean tx coverage per mapper and condition')

# NOTE: why is intron/pre coverage so high?
# I think this is because of an edge effect at intron/exon boundaries. Reads that overlap only 1 bp with intron are counted for their full rl. 
# The longer the intron, the less this influence gets:
# tab %>% filter(conversion_rate==0, mapper=='simulated') %>% ggplot(aes(len, value)) + geom_point() + facet_wrap(ftype~true_isoform, scales='free') + geom_vline(xintercept = 100, col='red')
# for exons, this effect is reduced by the edge effect on the 1st and last exon:
#tab %>% filter(conversion_rate==0, mapper=='simulated', ftype=='exon') %>% left_join(m[['fx']]) %>% mutate(is_edge=(rnk==1 | rnk==tx_rnk)) %>% 
#  ggplot(aes(x=is_edge, y=value)) + geom_boxplot() + facet_wrap(ftype~true_isoform, scales='free') 

```