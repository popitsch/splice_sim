---
title: "splice_sim_paper.Rmd"
author: "niko.popitsch@imba.oeaw.ac.at"
documentclass: article
fontsize: 10pt
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 14
    fig_height: 10
    fig_caption: true
    df_print: paged
  pdf_document:
    fig_width: 12
    fig_height: 10
    fig_caption: true
params:
    splice_sim_config:
       value: "/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/big4_slamseq_nf/splice_sim.config.json"
    decay_config:
       value: "/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/decay_sim_nf4_intron/config.json"
    out_dir:
       value: "/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/big4_slamseq_nf/analysis/"
---
<style type="text/css">
body, td {
   font-size: 10px;
}
code.r{
  font-size: 10px;
}
pre {
  font-size: 10px
}
div.blue pre { background-color:lightblue; }
div.blue pre.r { background-color:blue; }
</style>

<!--
rmarkdown::render('splice_sim_paper.Rmd', 'html_document')
-->

# INIT

```{r setup, include=FALSE}
require(data.table)
require(tidyr)
require(dplyr)
require(ggplot2)
require(scales)
require(rjson)
require(stringr)
require(VGAM)
require(cowplot)
require(arrow)
require(tictoc)
require(ggpubr)
require(minpack.lm)
require(readr)
require(testthat)
require(RColorBrewer)
require(skimr)
require(ggforce)
require(writexl)
require(xfun)
require(forcats)
# NB install arrow with snappy on Rstudio server
# Sys.setenv(ARROW_WITH_SNAPPY = "ON")
# Sys.setenv(NOT_CRAN="true")
# Sys.setenv(LIBARROW_BINARY="FALSE")
# install.packages("arrow", repos = "https://arrow-r-nightly.s3.amazonaws.com")

# to ensure stripping '\0' (nul) from character vector
options(arrow.skip_nul = TRUE)

# global theme
ggplot2::theme_set(theme_light())

# enable tidylog (has overhead!)
#require(tidylog)
# turn tidylog off
options("tidylog.display" = list()) 

# load data from TSV
load_table = function(dataF, append="", header=T, nrows=Inf) {
  dataF = as.character(paste0(dataF, append))
  print(paste("Loading", dataF))
  if ( endsWith(dataF, ".gz") ) {
    return(fread(cmd=paste('gunzip -c', dataF), header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  } else {
    return(fread(dataF, header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  }
}

# multiple plots with single title
my_plot_grid = function(plots, main, ncol=NULL, nrow=NULL, labels=NULL) {
  
  if (!is.null(labels)){
    if (labels==T) { labels=LETTERS[1:length(plots)] }
  }
  plot_row=plot_grid(plotlist=plots, ncol=ncol, nrow=nrow, labels=labels)
  title <- ggdraw() + draw_label( main, fontface = 'bold', x = 0, hjust = 0 ) + theme(plot.margin = margin(0, 0, 0, 7))
  return (plot_grid(title, plot_row, ncol = 1, rel_heights = c(0.1, 1)))
}

# calculate confidence interval (ci),  a measure of precision 
# call with mtcars %>% calc_ci(mpg) or mtcars %>% group_by(cyl) %>% calc_ci(mpg)
# plot with ...  %>% ggplot(aes(x=cyl, y=col.mean)) + geom_line() + geom_ribbon(aes(ymin=col.lower, ymax=col.upper), alpha=0.1 ...)
calc_ci = function(d, col, min_lower_ci=NA, max_upper_ci=NA) {
  ret = d %>% summarise(
            col.mean := mean({{col}}, na.rm = TRUE),
            #col.median := median({{col}}, na.rm = TRUE),
            col.sd = sd({{col}}, na.rm = TRUE),
            col.n = n(),
            .groups = 'drop') %>%
  mutate(stderr = col.sd / sqrt(col.n),
         col.lower = col.mean - qt(1 - (0.05 / 2), col.n - 1) * stderr,
         col.upper = col.mean + qt(1 - (0.05 / 2), col.n - 1) * stderr) %>% 
  ungroup() %>% 
  mutate(col.lower = pmax(min_lower_ci, col.lower, na.rm=T),
         col.upper = pmin(max_upper_ci, col.upper, na.rm=T))
  return (ret)
}

# calculate interquartile range (iqr), a measure of dispersion
# call with mtcars %>% calc_iqr(mpg) or mtcars %>% group_by(cyl) %>% calc_iqr(mpg)
# plot with  ... %>% ggplot(aes(x=cyl, y=col.median)) + geom_line() + geom_ribbon(aes(ymin=col.lower, ymax=col.upper), alpha=0.1 ...)
calc_iqr = function(d, col) {
  d %>% summarise(
            col.median = median({{col}}, na.rm = T),
            #col.mean = mean({{col}}, na.rm = T),
            col.upper = quantile({{col}}, .75, na.rm = T),
            col.lower = quantile({{col}}, .25, na.rm = T),
            col.n = n(),
            .groups = 'drop')
}

# calculate outlier cutoffs based on IQR
# Lower Bound: (Q1 - 1.5 * IQR)
# Upper Bound: (Q3 + 1.5 * IQR)
# usage: mtcars %>% group_by(cyl) %>% calc_outlier(mpg)
calc_outlier = function(d, col) {
  d %>% summarise(
            col.median = median({{col}}, na.rm = T),
            col.iqr = quantile({{col}}, .75, na.rm = T)-quantile({{col}}, .25, na.rm = T),
            col.upper = quantile({{col}}, .75, na.rm = T) + 1.5 * col.iqr,
            col.lower = quantile({{col}}, .25, na.rm = T) - 1.5 * col.iqr,
            col.n = n(),
            .groups = 'drop')
}

#
# write result tibble to BED file
#
write_bed = function(dat, bed_file, title, header=F) {
  sink(bed_file)
  cat(paste0("track name=",title," description=\"",title,"\" useScore=1 itemRgb=\"On\"\n"))
  sink()
  dat %>% write_tsv( bed_file, col_names = F, append = T ) 
}

# calculates performance and coverage on grouped data.
# required columns: count, classification, len
calc_performance=function(tab, readlen) {
  tab %>% 
    summarise(count=sum(count)) %>% 
    pivot_wider(names_from=classification, values_from=count, names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      read_count=TP+FN,
      cov=read_count*!!readlen/len,
      precision=ifelse(TP+FP>0, TP/(TP+FP), NA),
      recall=ifelse(TP+FN>0,TP/(TP+FN), NA),
      F1=ifelse((2*TP+FP+FN)>0,2*TP/(2*TP+FP+FN),NA)
  ) 
}

# calculate coverage for a grouped table
calc_coverage = function(grp_tab) {
  grp_tab %>% 
      summarise(count=sum(count)) %>% 
      pivot_wider(names_from=c(mapper,classification), values_from=count, names_sort=T) %>% 
      mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
      filter(len>conf$readlen) %>% # filter too-short introns as this will lead to wrong coverage calc. Example: ENSMUST00000116560.2_in5
      mutate(
        simulated=(HISAT3N_TP+HISAT3N_FN)*!!conf$readlen/len, # same as simulated_star!
        HISAT3N=(HISAT3N_TP+HISAT3N_FP)*!!conf$readlen/len,
        STAR=(STAR_TP+STAR_FP)*!!conf$readlen/len,
    ) %>% pivot_longer(c(simulated, HISAT3N, STAR), names_to='mapper') %>% 
    mutate(mapper=factor(mapper, levels=c('simulated', 'HISAT3N', 'STAR')),
           is_converted=ifelse(conversion_rate==0,'no conversions', 'converted reads')) %>% 
    ungroup()
}

# simple exponential decay model
decay_model= function(t, k) {
  return( exp(t * -k) )
}
# fit decay model and calculate halflife
fit_halflife = function(TP, dat) {
  if (any(is.na(dat))) {
    return (list(mod=NA,k=NA,hl=NA,pseudoR2=NA, bic=NA))
  }
  mod = tryCatch({
        nlsLM(dat~decay_model(TP, k),
              start=list(
                k=0),
              lower = c(0),                 
              upper = c(Inf),
              control = nls.lm.control(maxiter = 1000),
              na.action = na.omit)
      }, error=function(e){
        print(e)
      })
  if ( inherits(mod, "simpleError")) {return (list(mod=NA,k=NA,hl=NA,pseudoR2=NA, bic=NA)) }
  k=coef(mod)[length(coef(mod))]
  hl=ifelse(k>0, log(2)/k, NA)
  rss = sum(residuals(mod)^2)
  tss = sum((dat - mean(dat ,na.rm = TRUE))^2 ,na.rm = TRUE)  # Total sum of squares
  pseudoR2 = 1 - (rss/tss)  # R-squared measure
  bic = BIC(mod)
  return (list(mod=mod,k=k,hl=hl,pseudoR2=pseudoR2, bic=bic))
}

# simple correlation plot
plot_corr = function(d, a, b, col_, shape_=NULL, main_title=NA, xlog=F, draw_diag=T, max_x=NA, show_legend=T) {
  thecor = paste("r_pearson = ", round(cor(d[[a]], d[[b]], use = "complete.obs"), 4), 
                 "\nr_spearman = ", round(cor(d[[a]], d[[b]], use = "complete.obs", method="spearman"), 4),
                 "\nn =",nrow(na.omit(d %>% select(all_of(a),all_of(b))))  )
  if (is.na(main_title)) {
    main_title=paste0("Correlation between ",a," and ",b)
  }
  p = ggplot( d, aes_string(x=a, y=b, col=col_, shape=shape_) ) +
    geom_point(aes(alpha=0.2))  +
    ggtitle(main_title, thecor) 
  if ( !is.na(max_x) ) {
    p=p+xlim(0,max_x)+ylim(0, max_x)
  }
  if (draw_diag) {
    p=p+geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted") 
  }
  if ( xlog ) {
    p=p+scale_x_log10()+scale_y_log10()
  }
  if ( ! show_legend ) {
    p=p+theme(legend.position="none")
  }
  return(p)
}

gn2tid = function(gn) {
  return(unique( m[['ga']] %>% filter(gene_name == gn) %>% pull(tid) ))
}
tid2coord = function(tid) {
  return(unique( m[['tx']] %>% filter(tid == !!tid) %>% select(chromosome, start, end) ))
}

# cache results
# usage: d = cache({x %>% head()}, 'x_head')
cache = function(my_expr, name, rerun=F) {
  xfun::cache_rds(my_expr, rerun=rerun, dir=paste0(params$out_dir, '/cache/'), file=name)
}

clean_cache = function() {
  cached_files = list.files(paste0(params$out_dir, '/cache/'), '_[0-9a-f]{32}[.]rds$', full.names = TRUE)
  unlink(cached_files)
}

```


# data

```{r data, include=F, echo=F, cache=T, eval=F}

home_dir=paste0(dirname(params$splice_sim_config),'/')
conf=fromJSON(paste(readLines(params$splice_sim_config), collapse=""))
# create result dir?
if (!dir.exists(params$out_dir)) {
  dir.create(params$out_dir)
} 
if (!dir.exists(paste0(params$out_dir,'/cache/'))) {
  dir.create(paste0(params$out_dir,'/cache/'))
} 


#home_dir='/Users/niko.popitsch/Desktop/data/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/'


# results files (~45 G) 
data_file=paste0(home_dir,'/eva/results/data.rds')
data_file_mq20=paste0(home_dir,'/eva/results/data.mq20.rds')
meta_file=paste0(home_dir,'/eva/results/meta.rds')
  
if (file.exists(data_file)) {
  tic("load data")
  d=readRDS(data_file)
  d_mq20=readRDS(data_file_mq20)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(meta_file)) {
  tic("load metadata")
  m=readRDS(meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}


# to calc performance data
# d[['fx']] %>% 
#   group_by(fid,mapper,conversion_rate,classification,len,gene_name,num_exons,ftype) %>% 
#   calc_performance(conf$readlen) 

# to add meta data
# %>% 
#   left_join(m[['tx']], by=c('fid'='tid')) %>% # NB too-short tx are lost
#   left_join(m[['ga']], by=c('fid'='tid')) 


# shortcuts
tx = d[['tx']] %>% left_join(m[['tx']], by=c('fid'='tid')) 
tx20 = d_mq20[['tx']] %>% left_join(m[['tx']], by=c('fid'='tid')) 
fx = d[['fx']] %>% left_join(m[['fx']], by='fid') 
fx20 = d_mq20[['fx']] %>% left_join(m[['fx']], by='fid') 


# ===========================================================
# bam stats
# ===========================================================
if (dir.exists(paste0(home_dir,'/eva/bamstats'))) {
  d[['bam_stats']]=tibble()
  for ( f in list.files(paste0(home_dir,'/eva/bamstats'), pattern='\\.bamstats.tsv$', full.names = T)) {
    d[['bam_stats']] = d[['bam_stats']] %>% bind_rows(load_table(f))
  }
}

# result tables
results=list()
```


## QC

### BAM stats
```{r bam_stats, include=T, echo=F, cache=T}
bam_stats = d[['bam_stats']] %>% 
  rename(conversion_rate=cr) %>% 
  group_by(mapper, conversion_rate, ftype) %>% 
  summarise(
    n_reads=sum(n_reads),
    n_softclipped_reads=sum(n_softclipped_reads),
    mean_span_reads=mean(mean_span_reads, na.rm=T),
    mean_len_spliced_reads=mean(len_spliced_reads, na.rm=T),
    n_unmapped=sum(n_unmapped),
    n_spliced_reads=sum(n_spliced_reads),
  ) %>% 
  mutate(conversion_rate=factor(conversion_rate), 
         frac_spliced=n_spliced_reads/n_reads,
         frac_softclipped=n_softclipped_reads/n_reads,
         cat='bam_stats') 

count_stats = d[['tx']] %>% 
  group_by(mapper, conversion_rate, classification) %>% 
  summarise(c=sum(count)) %>% 
  pivot_wider(names_from = classification, values_from = c) %>% 
  mutate(n_reads=FN+TP, cat='counts') 

p1 = bam_stats %>% 
  bind_rows(count_stats) %>% 
  ggplot(aes(conversion_rate,n_reads, fill=cat)) +
  facet_wrap(mapper~.) +
  geom_col(position = 'dodge')

p2 = bam_stats %>%
 ggplot(aes(cr,n_spliced_reads, fill=mapper)) +
 geom_col(position = 'dodge')

p3 = bam_stats %>% 
  ggplot(aes(cr,frac_spliced, fill=mapper)) +
  geom_col(position = 'dodge')

p4 = bam_stats %>% 
  ggplot(aes(cr,frac_softclipped, fill=mapper)) +
  geom_col(position = 'dodge')

p5 = bam_stats %>% 
  ggplot(aes(cr,mean_span_reads, fill=mapper)) +
  geom_col(position = 'dodge')

p6 = bam_stats %>% 
  ggplot(aes(cr,len_spliced_reads, fill=mapper)) +
  geom_col(position = 'dodge')

my_plot_grid(list(p1,p2,p3,p4,p5,p6), 'bam stats', labels = T)
ggsave(paste0(params$out_dir, 'bam_stats.pdf'), width=12, height=10)

# mean_span_reads: mean(r.reference_end-r.reference_start+1)
# len_spliced_reads: mean(max_N-block_per_read)
```

### NA counts

Calculate and plot the fraction of NA counts per table/column

```{r non_na, include=T, echo=F, cache=T}
# count non-NA values per column for all passed tables
count_na_per_column = function(tables) {
 counts=tibble()
 for (name in names(tables)) {
    print(name)
    tab=tables[[name]]
    nr=nrow(tab)
    if (!is.null(nr)) {
      if (nr>0) {
        counts=counts %>% rbind(
          tab %>% select(everything()) %>% summarise_all(funs(sum(is.na(.)))) %>% mutate(table=!!name) %>% collect() %>% pivot_longer(-table) %>% mutate(nr=!!nr, frac=value/nr)
        )
      }
    }
  }
  return (counts)
}

non_na_counts = count_na_per_column(c(setNames(d, paste0('d_',names(d))),setNames(m, paste0('m_',names(m)))) )
ggplot(non_na_counts, aes(x=name, y=frac)) +
  geom_bar(stat='identity') +
  facet_wrap(table~., scales = 'free') +
  ggtitle("Fraction of NA counts per table column") + 
  xlab("") + ylab("") +
  ylim(0,1) +
  coord_flip() 

ggsave(paste0(params$out_dir, 'qc_non_na_counts.pdf'), width=12, height=10)
```

### Missing tids

Some of the originally configured transcript ids are missing from result data. 
This is either because 
- there were no reads simulated as the annotation is smaller than read-size and there are no (longer) overlapping transcripts
- annotations are very long (e.g., Kcnip1 or Cmss1)

```{r missing_tids, include=T, echo=F, cache=T}
# how many tx did we recover
found_tids=unique(d[['tx']] %>% pull(fid))
missing_tids=setdiff(m[['all_tids']],found_tids)
print(paste0("We have data for ", length(found_tids), '/', length(m[['all_tids']]), " tx"))

# what are the missing tx?
missing_tx=load_table('/groups/ameres/Niko/projects/Ameres/splicing/data/slamstr/pooled.mm10.all/pooled.mm10.all.Slamstr.stats.trans.final.tsv.gz') %>% 
  select(tid=transcript_id, gene_type, len, ilen) %>% 
  filter(tid %in% m[['all_tids']]) %>% 
  mutate(cat=ifelse(tid %in% found_tids, 'recovered','missing')) 
p1=missing_tx %>% ggplot(aes(x=factor(cat), y=len)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Length distribution of recovered vs missing tx") +
  geom_hline(yintercept = conf$readlen, col='red')
p2=missing_tx %>% ggplot(aes(x=factor(cat), y=ilen)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Intron Length distribution of recovered vs missing tx") +
  geom_hline(yintercept = conf$max_ilen, col='red')
# did we recover all reads?
p3 = d[['tx']] %>% group_by(mapper, conversion_rate, classification) %>% summarise(count=sum(count)) %>% pivot_wider(names_from=classification, values_from=count) %>% 
mutate(all=TP+FN) %>% ggplot(aes(conversion_rate, all, fill=mapper)) + geom_bar(stat='identity', position='dodge') + ggtitle('read counts per mapper/condition')

my_plot_grid(list(p1,p2,p3), labels=T, 'QC only', nrow = 1)
ggsave(paste0(params$out_dir, 'qc_missing_tids.pdf'), width=12, height=10)

```


### Comparison of counts for unspliced tx

```{r unspliced_counts, include=T, echo=F, cache=T}
tab = tx %>% # NB too-short tx are lost
  filter(rnk==1, conversion_rate=='0.1') %>% 
  mutate(is_overlapping=ifelse(n_overlapping>0, 'overlaps tx', 'no overlap')) %>% 
  group_by(fid, mapper, true_isoform, classification, mappability,is_overlapping ) %>% 
  summarise(count=sum(count)) %>% 
  pivot_wider(names_from = classification, values_from=count) %>% 
  mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
  mutate(F1=ifelse((2*TP+FP+FN)>0,2*TP/(2*TP+FP+FN),NA)) %>% 
  select(fid,mapper,true_isoform,F1,FP,FN,TP,FP_raw,mappability, is_overlapping) %>% 
  pivot_wider(names_from = true_isoform, values_from = c(F1,FP,FN,TP,FP_raw)) %>% 
  mutate(f1_diff=F1_mat-F1_pre) 
  
p1 = tab %>% ggplot(aes(mapper, f1_diff)) + geom_boxplot() + 
  facet_wrap(mappability~is_overlapping) +
  geom_hline(yintercept = 0, col='red') +
  ggtitle("Difference in F1 value between pre/mat.",
          "Should be close to zero!") 

p2 = tab %>% ggplot(aes(x=f1_diff)) + geom_density() + 
  ggtitle("Difference in F1 value between pre/mat.",
          "Should be close to zero!") +
  facet_wrap(mapper~is_overlapping) +
  geom_vline(xintercept = 0, col='red')

p3 = tab %>% ggplot(aes(x=FP_mat, y=FP_pre, col=mappability, alpha=0.05)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~is_overlapping) + geom_abline(slope=1, intercept=0) + theme(legend.position="none") +
  ggtitle('FP: caveat: isoform from originating read!')
p4 = tab %>% ggplot(aes(x=FN_mat, y=FN_pre, col=mappability, alpha=0.05)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~is_overlapping) + geom_abline(slope=1, intercept=0) + theme(legend.position="none") +
  ggtitle('FN')
p5 = tab %>% ggplot(aes(x=TP_mat, y=TP_pre, col=mappability, alpha=0.05)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~is_overlapping) + geom_abline(slope=1, intercept=0) + theme(legend.position="none") +
  ggtitle('TP')
p6 = tab %>% ggplot(aes(x=FP_raw_mat, y=FP_raw_pre, col=mappability, alpha=0.05)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~is_overlapping) + geom_abline(slope=1, intercept=0) +
  ggtitle('FP: caveat: isoform from originating read!')

my_plot_grid(list(p1,p2,p3,p4,p5,p6), 
             main="QC: comparing isoform performance (pre vs mat) for unspliced transcripts with Conversion_rate==0.1") 

ggsave(paste0(params$out_dir, 'qc_F1_unspliced.pdf'), width=12, height=10)

# example for considerable difference: ENSMUST00000226445.1
# tab %>% filter(FP_mat<10, FP_mat-FP_pre>5, mapper=='STAR') %>% left_join(m[['tx']], by=c('fid'='tid'))
```

# Tx / Fx Mappabilioty
## Coverage

- The target coverage is ~50X per isoform, i.e., 100X overall
- There is an edge effect as reads that overlap with 1bp are counted for their full length when coverage is calculated.
  This could explain the increased mean coverage for exons and introns. 
  For exons this effect is a bit reduced as the 1st/last exon also has an edge effect as we don't simulate reads that overlap the tx edges.

<div class = "blue">
<b>Coverage of simulated/mapped reads per isoform/genomic feature.</b>
A) Coverage distributions calculated from unconverted reads only (conversion rate = 0). 
   Both mappers have problems with spliced read mapping indicated by reduced coverage of spliced reads (panel mat/exon)
   and increased coverage of mature isoform reads that were false-positively mapped to introns (panel mat/intron). 
   Presumably, most of these reads are overlapping the splice junctions.
B) Mean coverage per conversion rate. 
   STAR shows decreased coverage of spliced reads with increasing conversion rates while HISAT3N is unaffected by this.
Note that deviations of the configured ~100X coverage for this 1:1 mix of premature/mature isoforms presumably stems from edge effects of the coverage
calculation that does not take partial read overlap into account. Coverage thresholds 0,50,100 are indicated by grey horizontal lines.
</div>


```{r coverage, include=T, echo=F, cache=T}

hlines=tribble(
  ~y,  ~cat,
  0,   1,
  50,  2,
  100, 3
)

cov_tx = cache({
  calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, len, classification ) ) 
}, 'cov_tx', rerun = F)

cov_tx2 = cache({
  calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, true_isoform, len, classification ) ) 
}, 'cov_tx2', rerun = F)

cov_fx = cache({
 calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification ))
}, 'cov_fx', rerun = F)

cov_fx2 = cache({
  calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, ftype, len, classification ))
}, 'cov_fx2', rerun = F)


pdf(paste0(params$out_dir, 'cov.pdf'), width=12, height=10)

p1 = cov_tx %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + 
  geom_boxplot() +
  scale_y_sqrt() +
  facet_grid(is_converted~., scales = 'free') +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage over tx interval') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p3 = cov_fx2 %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p4 = cov_tx2 %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per isoform') +
  facet_grid(is_converted~true_isoform, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

my_plot_grid(list(p1,p2,p3,p4), nrow=2, labels=T, 'QC: Coverage for converted and unconverted reads')

# final
p1 = cov_fx %>% 
  filter(is_converted=='no conversions') %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx %>% group_by(conversion_rate, ftype, true_isoform, mapper) %>% calc_ci(value) %>% 
  ggplot(aes(x=conversion_rate, y=col.mean, col=mapper, group=mapper)) + 
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean coverage per condition') +
  facet_grid(.~true_isoform+ftype)

my_plot_grid(list(p1,p2), labels=T, 'Coverage per mapper', nrow = 1)


# calc_coverage(d[['tx']] %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% group_by(conversion_rate,mapper) %>% summarise(m=mean(value)) %>% ggplot(aes(conversion_rate,m,fill=mapper)) + geom_bar(stat='identity', position = 'dodge') + ggtitle('Mean tx coverage per mapper and condition')

# NOTE: why is intron/pre coverage so high?
# I think this is because of an edge effect at intron/exon boundaries. Reads that overlap only 1 bp with intron are counted for their full rl. 
# The longer the intron, the less this influence gets:
# tab %>% filter(conversion_rate==0, mapper=='simulated') %>% ggplot(aes(len, value)) + geom_point() + facet_wrap(ftype~true_isoform, scales='free') + geom_vline(xintercept = 100, col='red')
# for exons, this effect is reduced by the edge effect on the 1st and last exon:
#tab %>% filter(conversion_rate==0, mapper=='simulated', ftype=='exon') %>% left_join(m[['fx']]) %>% mutate(is_edge=(rnk==1 | rnk==tx_rnk)) %>% 
#  ggplot(aes(x=is_edge, y=value)) + geom_boxplot() + facet_wrap(ftype~true_isoform, scales='free') 


#remove()

dev.off()

```


## MAP Performance

<div class = "blue">
<b>Mapping performance per conversion rate.</b>
Precision, recall and F1 score per feature type (tx: transcript), stratified by originating isoform (pre: premature, unspliced isoform; mat: mature, fully spliced isoform) and standard genomic mappability. 
Performance drops with increasing conversion rate for STAR but not HISAT3N.
</div>

```{r map_perf, include=T, echo=F, cache=T}

perf_tx = cache({
  tx %>% 
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_tx', rerun = F)

perf_fx = cache({
  fx %>% 
    select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_fx', rerun = F)


perf = bind_rows(perf_tx, perf_fx) 
  

pdf(paste0(params$out_dir, 'map_perf.pdf'), width=8, height=6)

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(precision) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median precision per condition') 

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(recall) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median recall per condition') 

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5)) +
  ylab("F1") +
  ggtitle('Median F1 per condition') 


perf_tx %>% filter(mappability=='high') %>% 
  group_by(conversion_rate, mapper, true_isoform, num_exons) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_wrap(num_exons~.) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per tx', 'by number of exons (high mappability only)') 


dev.off()
```
### MAP Correlation of F1 and genomic mappability

```{r map_corr, include=T, echo=F, cache=T}
pdf(paste0(params$out_dir, 'map_corr.pdf'), width=12, height=10)

perf %>% 
  filter(conversion_rate==0.1) %>% 
  ggplot(aes(mean_map, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", trans = "log", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("mean genomic mappability") +
  ggtitle('Mean mappability vs F1', 'cr=10%') 

perf %>% 
  filter(conversion_rate==0.1) %>% 
  ggplot(aes(GC, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("GC%") +
  ggtitle('GC vs F1', 'cr=10%') 

perf %>% 
  filter(conversion_rate==0.1) %>% 
  ggplot(aes(rnk, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("number of exons") +
  ggtitle('Number of exons in tx vs F1', 'cr=10%') 

perf %>% 
  filter(conversion_rate==0.1) %>% 
  ggplot(aes(frac_convertible, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("frac_convertible") +
  ggtitle('frac_convertible vs F1', 'cr=10%') 


# Does convertibility influence performance? Some effect seen for low mappability  
perf_fx %>% 
  filter(ftype=='exon') %>% 
  group_by(conversion_rate, mapper, mappability, ftype, true_isoform, convertibility) %>% 
  calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~convertibility, scales = 'free', labeller = label_both) +
  ylab("") +
  ggtitle('Mean exonic F1 per convertibility class', 'cr=10%') 

dev.off()
```
### MAP result tables

TODO: add mq20 F1 values?

```{r map_results, include=T, echo=F, cache=T}
calc_map_table = function(tab) {
  tab = tab %>% 
  select(fid, ftype, mapper, conversion_rate, classification, count) %>% 
  group_by(fid, ftype, mapper, conversion_rate, classification) %>% 
  summarise(count=sum(count), .groups='drop') %>%
  pivot_wider(names_from=classification, values_from=count) %>%
  mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
  mutate(F1=ifelse(((2*TP+FP+FN)>0) & (TP+FN>0),2*TP/(2*TP+FP+FN),NA))
  
  # calc F1 from conversion_rate==0 only
  noconv=tab %>% filter(conversion_rate==0) %>% select(fid, mapper, ftype, F1_0=F1)
  # create final table
  tab = tab %>% group_by(fid,ftype,mapper) %>% 
    summarise(TP=sum(TP), FP=sum(FP), FN=sum(FN), .groups='drop') %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(F1=ifelse(((2*TP+FP+FN)>0) & (TP+FN>0),2*TP/(2*TP+FP+FN),NA)) %>% # set F1 to NA if no reads were simulated for tx (e.g., because too short)
    left_join(noconv, by=c('fid', 'mapper', 'ftype')) %>% # add F1_0
    pivot_wider(names_from=mapper, values_from=c(F1_0, F1), id_cols=c('fid', 'ftype'))
  
  return(tab)
}


# result tables
results[['map_tx_tab']] = tx %>% calc_map_table() %>% rename(tid='fid') %>% 
  mutate(best_mapper_no_conv = ifelse(F1_0_HISAT3N-F1_0_STAR>0.05, 'HISAT3N',
                               ifelse(F1_0_HISAT3N-F1_0_STAR< -0.05,'STAR','BOTH')),
         best_mapper_conv = ifelse(F1_HISAT3N-F1_STAR>0.05, 'HISAT3N',
                            ifelse(F1_HISAT3N-F1_STAR< -0.05,'STAR','BOTH'))) %>% 
  left_join(m[['tx']], by=c('tid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['map_ex_tab']] = fx %>% filter(ftype=='exon') %>% calc_map_table() %>% 
  mutate(best_mapper_no_conv = ifelse(F1_0_HISAT3N-F1_0_STAR>0.05, 'HISAT3N',
                               ifelse(F1_0_HISAT3N-F1_0_STAR< -0.05,'STAR','BOTH')),
         best_mapper_conv = ifelse(F1_HISAT3N-F1_STAR>0.05, 'HISAT3N',
                            ifelse(F1_HISAT3N-F1_STAR< -0.05,'STAR','BOTH'))) %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['map_in_tab']] = fx %>% filter(ftype=='intron') %>% calc_map_table() %>% 
  mutate(best_mapper_no_conv = ifelse(F1_0_HISAT3N-F1_0_STAR>0.05, 'HISAT3N',
                               ifelse(F1_0_HISAT3N-F1_0_STAR< -0.05,'STAR','BOTH')),
         best_mapper_conv = ifelse(F1_HISAT3N-F1_STAR>0.05, 'HISAT3N',
                            ifelse(F1_HISAT3N-F1_STAR< -0.05,'STAR','BOTH'))) %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

```


### MAP Write BED file of best mapper 
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of best mapper
# ==============================================
results[['map_tx_tab']] %>%
  mutate(score=round(pmax(F1_HISAT3N, F1_STAR)*1000),
         best_mapper=best_mapper_conv,
         rgb=ifelse(best_mapper=='HISAT3N','255,0,0','0,255,0'),
         start1=start,
         end1=end
         ) %>% 
  arrange(chromosome, start) %>% 
      select(chromosome,start,end,best_mapper,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/best_mapper_map.include_converted.bed'),
                paste0("best_mapper_map.include_converted"))

results[['map_tx_tab']] %>%
  mutate(score=round(pmax(F1_0_HISAT3N, F1_0_STAR)*1000),
         best_mapper=best_mapper_no_conv,
         rgb=ifelse(best_mapper=='HISAT3N','255,0,0','0,255,0'),
         start1=start,
         end1=end
         ) %>% 
  arrange(chromosome, start) %>% 
      select(chromosome,start,end,best_mapper,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/best_mapper_map.unconverted_only.bed'),
                paste0("best_mapper_map.unconverted_only"))
```

## FCR


```{r fcr, include=T, echo=F, cache=T}
fcr = cache({
  tx %>% 
    bind_rows(fx) %>% 
    group_by(fid, mapper, conversion_rate, classification, true_isoform, mappability, ftype) %>% 
    summarise(all=sum(count), 
              tc1=sum(count[cv1==1]), 
              tc2=sum(count[cv2==1])) %>% 
    pivot_wider(names_from=classification, values_from=c(all, tc1, tc2), names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      all_true =  all_TP+all_FN,
      all_found = all_TP+all_FP,
      tc1_true =  tc1_TP+tc1_FN,
      tc1_found = tc1_TP+tc1_FP,
      tc2_true =  tc2_TP+tc2_FN,
      tc2_found = tc2_TP+tc2_FP,
      true_fcr1 = ifelse(all_true>0,tc1_true/all_true,0),
      found_fcr1 = ifelse(all_found>0,tc1_found/all_found,0),
      true_fcr2 = ifelse(all_true>0,tc2_true/all_true,0),
      found_fcr2 = ifelse(all_found>0,tc2_found/all_found,0),
      # performance
      all_precision=ifelse(all_TP+all_FP>0, all_TP/(all_TP+all_FP), NA),
      all_recall=ifelse(all_TP+all_FN>0,all_TP/(all_TP+all_FN), NA),
      all_F1=ifelse((2*all_TP+all_FP+all_FN)>0,2*all_TP/(2*all_TP+all_FP+all_FN),NA),
      tc1_precision=ifelse(tc1_TP+tc1_FP>0, tc1_TP/(tc1_TP+tc1_FP), NA),
      tc1_recall=ifelse(tc1_TP+tc1_FN>0,tc1_TP/(tc1_TP+tc1_FN), NA),
      tc1_F1=ifelse((2*tc1_TP+tc1_FP+tc1_FN)>0,2*tc1_TP/(2*tc1_TP+tc1_FP+tc1_FN),NA),
      tc2_precision=ifelse(tc2_TP+tc2_FP>0, tc2_TP/(tc2_TP+tc2_FP), NA),
      tc2_recall=ifelse(tc2_TP+tc2_FN>0,tc2_TP/(tc2_TP+tc2_FN), NA),
      tc2_F1=ifelse((2*tc2_TP+tc2_FP+tc2_FN)>0,2*tc2_TP/(2*tc2_TP+tc2_FP+tc2_FN),NA)
  ) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron')))
}, 'fcr', rerun=F)

# fcr %>% 
#   filter(mapper=='STAR') %>% 
#   ggplot(aes(conversion_rate, true_fcr1, alpha=0.1)) +
#   geom_boxplot() +
#   facet_grid(true_isoform~ftype+mappability) +
#   ggtitle("QC: Simulated fcr per conversion rate")

fcr_perf = cache({
  fcr %>%
    select(fid, conversion_rate,true_isoform,ftype,mappability,true_fcr1, found_fcr1) %>% 
    ungroup() %>% 
    pivot_wider(names_from=mapper, values_from=c(true_fcr1, found_fcr1)) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>%   # replace NA with 0; NA are resulting from mat not having introns. So if there are no FP values then there are no entries!
    rename(simulated=true_fcr1_HISAT3N, HISAT3N=found_fcr1_HISAT3N, STAR=found_fcr1_STAR) %>%
    select(-true_fcr1_STAR) %>% 
    mutate(diff_HISAT3N=HISAT3N-simulated, 
           diff_STAR=STAR-simulated,
           best_diff=pmin(abs(diff_HISAT3N), abs(diff_STAR)),
           best_mapper=case_when(
             best_diff>0.1 ~ 'None',
             abs(diff_HISAT3N)<0.05 & abs(diff_STAR)<0.05 ~ 'Both',
             abs(diff_HISAT3N)<abs(diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
           )
}, 'fcr_perf', rerun=F)

# result tables
fcr_tab = fcr_perf %>% 
  filter(as.numeric(as.character(conversion_rate))>0) %>% 
  group_by(fid, ftype) %>% 
  summarise(m_diff_HISAT3N = mean(diff_HISAT3N,na.rm=T), 
            m_diff_STAR = mean(diff_STAR,na.rm=T)) %>% 
  mutate(best_m_diff=pmin(abs(m_diff_HISAT3N), abs(m_diff_STAR)),
         best_mapper=case_when(
             best_m_diff>0.1 ~ 'None',
             abs(m_diff_HISAT3N)<0.05 & abs(m_diff_STAR)<0.05 ~ 'Both',
             abs(m_diff_HISAT3N)<abs(m_diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
         )

```

### FCR per condition

<div class = "blue">
<b>Fraction of converted reads.</b>
Fraction of converted reads (fcr), stratified by feature type and originating isoform.
Note that HISAT3N and STAR tend to slightly over- respctively underestimate FCR in exonic regions.
The non-zero FCR for mature introns results from false-positive intronic reads.

</div>

```{r fcr_perf, include=T, echo=F, cache=T}

fcr_perf %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(true_isoform~ftype)

ggsave(paste0(params$out_dir, 'fcr_perf.pdf'), width=12, height=10)

```

### FCR best mapper
<div class = "blue">
<b>Best mapper counts.</b>
Number of times a mapper 

</div>
```{r fcr_best_mapper, include=T, echo=F, cache=T}

pdf(paste0(params$out_dir, 'fcr_best_mapper.pdf'), width=12, height=10)

fcr_perf %>% group_by(conversion_rate, ftype, true_isoform) %>% 
  count(best_mapper) %>% 
  mutate(frac = n / sum(n)) %>% 
  ggplot(aes(conversion_rate, frac, fill=best_mapper)) + geom_bar(stat='identity', position = 'dodge') +
  ggtitle('Best mapper wrt. FCR per conversion rate/isoform') +
  facet_grid(true_isoform~ftype) +
  scale_y_sqrt()

fcr_perf %>% 
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(diff_HISAT3N, diff_STAR)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.01, 0.01)) +
  ggtitle('FCR difference to simulated values per mapper (mat isoform)')

fcr_tab %>% 
  group_by(ftype) %>% 
  count(best_mapper) %>% 
  ggplot(aes(best_mapper, n, fill=best_mapper)) +
    geom_bar(stat='identity') +
    facet_wrap(.~ftype, scales = 'free') +
    ggtitle('Best mapper wrt. FCR')

dev.off()
```

### FCR result tables
```{r fcr_results, include=T, echo=F, cache=T}
results[['fcr_tx_tab']] = fcr_tab %>% filter(ftype=='tx') %>%
  rename(tid=fid) %>% 
  left_join(m[['tx']], by=c('tid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['fcr_ex_tab']] = fcr_tab %>% filter(ftype=='exon') %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['fcr_in_tab']] = fcr_tab %>% filter(ftype=='intron') %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 
```

### FCR Write BED file of best mapper 
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of best FCR mapper
# ==============================================
tab = fcr_tab %>%
  filter(ftype=='tx') %>% 
  left_join(m[['tx']], by = c('fid'='tid')) %>% 
  arrange(chromosome, start)

tab %>% 
  mutate(score=1000,
         rgb=ifelse(best_mapper=='HISAT3N','255,0,0','0,255,0'),
         start1=start,
         end1=end) %>% 
      select(chromosome,start,end,best_mapper,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/best_mapper_fcr.bed'),
                paste0("best_mapper_fcr"))

```

# FMAT

```{r sj, include=T, echo=F, cache=T}

sj = cache({
  d[['sj']] %>% 
  group_by(mapper, conversion_rate, class_type, fid, true_isoform, classification) %>% 
  summarise(count=sum(count)) %>% 
  ungroup()
}, 'sj', rerun=F)

# QC: check classification of pre reads  
p1 = sj %>% filter(mapper=='HISAT3N') %>% group_by(true_isoform, classification, class_type) %>% summarise(count=sum(count)) %>% 
  ggplot(aes(classification, count, fill=true_isoform)) + geom_bar(stat='identity', position='dodge') + facet_grid(class_type~true_isoform) +
  ggtitle('HISAT3N') + theme(legend.position="none")
p2 = sj %>% filter(mapper=='STAR') %>% group_by(true_isoform, classification, class_type) %>% summarise(count=sum(count)) %>% 
  ggplot(aes(classification, count, fill=true_isoform)) + geom_bar(stat='identity', position='dodge') + facet_grid(class_type~true_isoform) +
  ggtitle('STAR') + theme(legend.position="none")
my_plot_grid(list(p1,p2), 'QC: premature reads should only be classified as acc/don\nThere cannot be TP/FN pre spl reads')

ggsave(paste0(params$out_dir, 'sj_qc.pdf'), width=12, height=10)

```


<div class = "blue">
<b>Intron filtering statistics.</b>
Number of filtered introns including or excluding converted datasets.
</div>

```{r sj_pre, include=T, echo=F, cache=T}
sj_per = cache({
  sj %>% 
    group_by(mapper, conversion_rate, fid, class_type, classification) %>% 
    summarise(count=sum(count)) %>% 
    pivot_wider(names_from=c(class_type, classification), values_from=count) %>% 
    ungroup() %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    left_join(m[['sj']], by='fid') %>% 
    mutate(
      spl_pre=ifelse(spl_TP+spl_FP>0, spl_TP/(spl_TP+spl_FP), NA),
      spl_rec=ifelse(spl_TP+spl_FN>0, spl_TP/(spl_TP+spl_FN), NA),
      spl_F1=ifelse((2*spl_TP+spl_FP+spl_FN)>0,2*spl_TP/(2*spl_TP+spl_FP+spl_FN),NA),
      acc_pre=ifelse(acc_TP+acc_FP>0, acc_TP/(acc_TP+acc_FP), NA),
      acc_rec=ifelse(acc_TP+acc_FN>0, acc_TP/(acc_TP+acc_FN), NA),
      acc_F1=ifelse((2*acc_TP+acc_FP+acc_FN)>0,2*acc_TP/(2*acc_TP+acc_FP+acc_FN),NA),
      don_pre=ifelse(don_TP+don_FP>0, don_TP/(don_TP+don_FP), NA),
      don_rec=ifelse(don_TP+don_FN>0, don_TP/(don_TP+don_FN), NA),
      don_F1=ifelse((2*don_TP+don_FP+don_FN)>0,2*don_TP/(2*don_TP+don_FP+don_FN),NA),
      true_mat=spl_FN+spl_TP,
      found_mat=spl_FP+spl_TP,
      true_pre=don_FN+don_TP+acc_FN+acc_TP,
      found_pre=don_FP+don_TP+acc_FP+acc_TP,
      true_spliced=ifelse(true_pre>0,true_mat/(true_pre+true_mat), NA),
      found_spliced=ifelse(found_pre>0,found_mat/(found_pre+found_mat), NA),
      spliced_diff=abs(true_spliced-found_spliced)
    )  %>% mutate(spliced_diff_rnk = dense_rank(spliced_diff)) # rank of difference to true spliced value. Bad introns have higher ranks
}, 'sj_per', rerun=F)

# ===============================================
# Calculate bad/filtered introns
# ===============================================
min_spliced_diff = 0.1 # filter SJ only if diff to true value is greater than this value
min_remaining_readcount = 100 # filter SJs util this remaining_readcount
intron_mappability = cache({
  sj_per %>% 
    group_by(tid, mapper, conversion_rate) %>% 
    arrange(spliced_diff_rnk) %>% 
    mutate(read_sum=cumsum(found_mat+found_pre)) %>% 
    select(tid, mapper, conversion_rate, fid, spliced_diff_rnk, spliced_diff, 
           true_pre, true_mat, found_pre, found_mat, read_sum) %>% 
    arrange(desc(spliced_diff_rnk)) %>% # sort per tx by decreasing intron rnk, i.e.,bad introns first
    mutate(remaining_reads=lead(read_sum, default=0)) %>% # remaining reads after removing the current intron
    mutate(low_map = (is.na(spliced_diff) | 
                        (spliced_diff>!!min_spliced_diff & remaining_reads>!!min_remaining_readcount))) %>% 
    group_by(mapper, tid, fid) %>% summarise(
      include_converted=ifelse(sum(low_map)>sum(!low_map),1,0),   # filter because in most conditions it is filtered
      unconverted_only=low_map[conversion_rate==0]  # filter because in cond0 it is filtered
      ) %>% 
  ungroup() %>% 
  pivot_longer(c(include_converted, unconverted_only), names_to = 'filter_type', values_to='filtered')
}, 'intron_mappability', rerun=F)


# ===============================================
# QC plots
# ===============================================

# plot distribution of low_mappability introns
levs=c('not filtered','filtered in STAR', 'filtered in HISAT3N', 'filtered in both')
intron_mappability %>% 
  pivot_wider(names_from=mapper, values_from = filtered, id_cols = c('tid', 'fid', 'filter_type')) %>% 
  mutate(lab=case_when(
    (HISAT3N) & (STAR) ~ 'filtered in both',
    (!HISAT3N) & (STAR) ~ 'filtered in STAR',
    (HISAT3N) & (!STAR) ~ 'filtered in HISAT3N',
    T ~ 'not filtered'
    )) %>% 
  count(filter_type, lab) %>% 
  ggplot(aes(x=lab, y=n, fill=lab)) +
  scale_fill_manual(name = "lab",values = setNames(brewer.pal(length(levs),"Set1"), levs)) +
  geom_bar(stat='identity') +
  facet_wrap(filter_type~.) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggtitle('Filter results per intron') 


intron_mappability %>% 
  left_join(m[['fx']], by=c('tid', 'fid')) %>% 
  pivot_wider(names_from=mapper, values_from = filtered, id_cols = c('tid', 'fid', 'filter_type', 'mappability')) %>% mutate(lab=case_when(
    (HISAT3N) & (STAR) ~ 'filtered in both',
    (!HISAT3N) & (STAR) ~ 'filtered in STAR',
    (HISAT3N) & (!STAR) ~ 'filtered in HISAT3N',
    T ~ 'not filtered'
    )) %>% 
  group_by(filter_type, mappability, lab) %>% 
  count() %>% 
  group_by(filter_type, mappability) %>% 
  mutate(s=sum(n), frac=n/s) %>% 
  ggplot(aes(x=lab, y=frac, fill=lab)) +
  scale_fill_manual(name = "lab",values = setNames(brewer.pal(length(levs),"Set1"), levs)) +
  geom_bar(stat='identity') +
  facet_grid(mappability~filter_type, scales = 'free') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggtitle('Filter results per intron') +
  xlab("") + theme(legend.position="none")

ggsave(paste0(params$out_dir, 'sj_intron_filtering.pdf'), width=12, height=10)
  
```

```{r sj_sfrac, include=T, echo=F, cache=T}
# Table to compare frac_spliced w/wo intron filtering

sfrac_conv = cache({
  sj_per %>% 
    left_join(intron_mappability, by=c('mapper', 'fid', 'tid' )) %>% 
    filter(filter_type=='include_converted') %>%  # TC part
    group_by(tid, mapper, conversion_rate, filter_type, tx_mappability) %>% 
    summarise(true_mat=sum(spl_FN)+sum(spl_TP),
              found_mat=sum(spl_FP)+sum(spl_TP),
              true_pre=sum(don_FN)+sum(don_TP)+sum(acc_FN)+sum(acc_TP),
              found_pre=sum(don_FP)+sum(don_TP)+sum(acc_FP)+sum(acc_TP),
              # --- filtered ----
              true_mat_fil=sum(spl_FN[!filtered])+sum(spl_TP[!filtered]),
              found_mat_fil=sum(spl_FP[!filtered])+sum(spl_TP[!filtered]),
              true_pre_fil=sum(don_FN[!filtered])+sum(don_TP[!filtered])+sum(acc_FN[!filtered])+sum(acc_TP[!filtered]),
              found_pre_fil=sum(don_FP[!filtered])+sum(don_TP[!filtered])+sum(acc_FP[!filtered])+sum(acc_TP[!filtered]),
              n_fil=sum(filtered, na.rm = T),
              .groups = 'drop'
           )
  }, 'sfrac_conv', rerun=F)

sfrac_unconv = cache({ 
  sj_per %>% 
    left_join(intron_mappability, by=c('mapper', 'fid', 'tid' )) %>% 
    filter(filter_type=='unconverted_only', conversion_rate==0) %>%  # no-TC part
    group_by(tid, mapper, conversion_rate, filter_type, tx_mappability) %>% 
    summarise(true_mat=sum(spl_FN)+sum(spl_TP),
              found_mat=sum(spl_FP)+sum(spl_TP),
              true_pre=sum(don_FN)+sum(don_TP)+sum(acc_FN)+sum(acc_TP),
              found_pre=sum(don_FP)+sum(don_TP)+sum(acc_FP)+sum(acc_TP),
              # --- filtered ----
              true_mat_fil=sum(spl_FN[!filtered])+sum(spl_TP[!filtered]),
              found_mat_fil=sum(spl_FP[!filtered])+sum(spl_TP[!filtered]),
              true_pre_fil=sum(don_FN[!filtered])+sum(don_TP[!filtered])+sum(acc_FN[!filtered])+sum(acc_TP[!filtered]),
              found_pre_fil=sum(don_FP[!filtered])+sum(don_TP[!filtered])+sum(acc_FP[!filtered])+sum(acc_TP[!filtered]),
              n_fil=sum(filtered, na.rm = T),
              .groups = 'drop'
           )
  }, 'sfrac_unconv', rerun=F)


sfrac = cache({ 
  bind_rows(sfrac_conv, sfrac_unconv) %>% 
  filter( found_mat_fil+found_pre_fil>!!min_remaining_readcount ) %>% # drop if due to filtering the overall readcount became too low
  mutate(
         true_spliced=ifelse(true_pre>0,true_mat/(true_pre+true_mat), NA),
         found_spliced=ifelse(found_pre>0,found_mat/(found_pre+found_mat), NA),
         found_spliced_fil=ifelse(found_pre_fil>0,found_mat_fil/(found_pre_fil+found_mat_fil), NA),
  ) %>% 
  mutate(diff_spliced=true_spliced-found_spliced,
         diff_spliced_fil=true_spliced-found_spliced_fil) %>% 
  mutate(improvement=abs(diff_spliced) - abs(diff_spliced_fil)) %>% 
  left_join(m[['tx']] %>% select(tid, n_overlapping, rnk), by='tid') %>% 
  left_join(m[['ga']] %>% select(tid, gene_type), by='tid')
  }, 'sfrac', rerun=F)

sfrac_ntx = sfrac %>% summarise(n_tids=n_distinct(tid)) %>% pull(n_tids)
sfrac_ntx2 = sfrac %>% filter(n_fil>0) %>% summarise(n_tids=n_distinct(tid)) %>% pull(n_tids)
print(glue::glue('We have data for {sfrac_ntx} tx or which {sfrac_ntx2} ({prettyNum(sfrac_ntx2*100/sfrac_ntx, digits=2)}%) have at  least 1 filtered intron) ')) 

pdf(paste0(params$out_dir, 'sj_fil.pdf'), width=12, height=10)

# plot difference to true fractions
sfrac %>% 
  select(mapper, tid, conversion_rate, filter_type, n_fil, improvement, 
         tx_mappability, n_overlapping) %>% 
  filter(n_fil > 0) %>% 
  mutate(is_overlapping=ifelse(n_overlapping>0,'overlapping tx', 'non-overlapping tx')) %>% 
  ggplot(aes(x=conversion_rate, y=improvement, fill=filter_type)) +
    geom_boxplot(outlier.colour = 'grey') +
    facet_grid(tx_mappability~mapper) +
    geom_hline(yintercept = 0, col='black') +
    ggtitle('Improvement per mapper for tx with at least one filtered intron')

sfrac %>%
  filter(n_fil>0, n_overlapping==0, gene_type=='protein_coding') %>%
  mutate(is_overlapping=ifelse(n_overlapping>0,'overlapping tx', 'non-overlapping tx')) %>%
  mutate(frac_filtered=round(n_fil/(rnk-1),1)) %>%
  group_by(mapper, frac_filtered, tx_mappability, is_overlapping, conversion_rate, filter_type) %>% 
  calc_iqr(improvement) %>%
  ggplot(aes(x=frac_filtered, y=col.median, col=mapper, group=mapper)) +
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=3, alpha=0.05) +
  geom_line() +
  geom_hline(yintercept = 0, col='black') +
  facet_grid(tx_mappability~paste0(is_overlapping,', cr=',conversion_rate, ', ft=', filter_type)) +
  ggtitle('Improvement of frac_mature estimate per fraction introns filtered',
          paste0('protein_coding only'))

dev.off()
```

## FMAT best tx per mapper
- calc for each tx: which mapper has smallest diff to sim truth after correction

```{r sj_corr_best_tx, include=T, echo=F, cache=T}
best_mapper_fmat = cache({
  sfrac %>% 
    select(mapper, tid, conversion_rate,filter_type, n_fil, n_overlapping, 
           true_spliced, found_spliced, found_spliced_fil, tx_mappability) %>% 
    group_by(mapper, tid, n_fil, n_overlapping, true_spliced, tx_mappability, filter_type) %>% 
    summarise( m_found_spliced=median(found_spliced, na.rm=T), 
               m_found_spliced_fil=median(found_spliced_fil)) %>% 
    ungroup() %>% 
    pivot_wider(names_from=mapper, 
                values_from=c(m_found_spliced, m_found_spliced_fil, n_fil), 
                id_cols=c('tid', 'n_overlapping', 'true_spliced', 'tx_mappability', 'filter_type')) %>% 
    mutate(diff_STAR=abs(true_spliced-m_found_spliced_STAR),
           diff_STAR_fil=abs(true_spliced-m_found_spliced_fil_STAR),
           diff_HISAT3N=abs(true_spliced-m_found_spliced_HISAT3N),
           diff_HISAT3N_fil=abs(true_spliced-m_found_spliced_fil_HISAT3N)
           ) %>%   
    mutate(best_HISAT3N=pmin(diff_HISAT3N, diff_HISAT3N_fil),
           best_STAR=pmin(diff_STAR, diff_STAR_fil )) %>% 
    mutate(best_diff=pmin(best_HISAT3N, best_STAR)) %>% 
    mutate(best_mapper_fmat=ifelse(best_HISAT3N<best_STAR, 'HISAT3N', ifelse(best_STAR<best_HISAT3N,'STAR','BOTH')),
           after_fil=(diff_STAR_fil==best_diff | diff_HISAT3N_fil==best_diff) & (diff_HISAT3N!=best_diff) & (diff_STAR!=best_diff),
           diff_to_other=abs(best_HISAT3N-best_STAR)
           ) 
}, 'best_mapper_fmat', rerun=F)
  
# TODO: add best mapper for tx that cannot be intron-filtered (rnk1)
p1 = best_mapper_fmat %>% 
  group_by(tx_mappability, after_fil, filter_type) %>% 
  count(best_mapper_fmat) %>% 
  ggplot(aes(x=best_mapper_fmat, y=n, fill=after_fil)) +
  geom_bar(stat='identity') +
  facet_grid(filter_type~.) +
  ggtitle('All' )

p2 = best_mapper_fmat %>% 
  filter(best_diff<0.05, diff_to_other>0.05) %>% 
  group_by(tx_mappability, after_fil, filter_type) %>% 
  count(best_mapper_fmat) %>% 
  ggplot(aes(x=best_mapper_fmat, y=n, fill=after_fil)) +
  geom_bar(stat='identity') +
  facet_grid(filter_type~tx_mappability) +
  ggtitle('Substantial improvement only',
          'best_diff<0.05, diff_to_other>0.05')

my_plot_grid(list(p1,p2), 'Best mapper per tx wrt. FMAT')

ggsave(paste0(params$out_dir, 'sj_bst_mapper.pdf'), width=12, height=10)

```

### FMAT result tables
```{r}
results[['spl_tx_tab']] = best_mapper_fmat %>% 
  left_join(m[['tx']] %>% select(-n_overlapping), by='tid') %>% 
  left_join(m[['ga']], by='tid')

```

### FMAT Write BED file of filtered introns per mapper
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of filtered introns per mapper
# ==============================================
tab = intron_mappability %>%
  left_join(m[['sj']], by = c('tid', 'fid'), all.x=T) %>% 
  arrange(chromosome, start)
for ( filter_type in c('include_converted', 'unconverted_only')) {
  for ( mapper in c('STAR', 'HISAT3N')) {
    tab %>% 
      filter(mapper==!!mapper, filter_type==!!filter_type) %>% 
      mutate(score=ifelse(is.na(don_win_map)|is.na(acc_win_map),0,(don_win_map+acc_win_map)/2*1000), 
             rgb=ifelse(filtered,'255,0,0','0,255,0'),
             start1=start,
             end1=end) %>% 
      select(chromosome,start,end,fid,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/filtered_introns_',filter_type,'.',mapper,'.bed'),
                paste0(mapper,"_filtered_introns_", filter_type))
  }
}
  
```

### FMAT Write BED file of best mapper
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of tx per best mapper
# ==============================================
tab = best_mapper_fmat %>%
  left_join(m[['tx']], by='tid') %>% 
  select(tid, filter_type, best_mapper_fmat, best_diff, diff_to_other, chromosome, start, end, strand) %>% 
  arrange(chromosome, start)


for ( filter_type in c('include_converted', 'unconverted_only')) {
  tab %>% 
    filter(filter_type==!!filter_type) %>% 
    mutate(score=ifelse(is.na(best_diff),0,(pmax(0,(1/3)-best_diff))*1000), 
           rgb=case_when(
             best_mapper_fmat=='STAR'~'255,0,0',
             best_mapper_fmat=='HISAT3N'~'0,255,0',
             T ~ '0,0,255'),
           start1=start,
           end1=end) %>% 
    select(chromosome,start,end,best_mapper_fmat,score,strand,start1,end1,rgb) %>% 
    write_bed( paste0(params$out_dir,'/best_mapper_fmat.',filter_type, '.bed'), 
               paste0('best_mapper_fmat_',filter_type))
}

```


# Special analyses

## Performance of converted vs unconverted reads


<div class = "blue">
<b>Fraction of false positive/negative reads stratified by nucleotide mismatches.</b>
We expected the fraction of FP/FN reads to increase with increasing mismatches to the reference sequence that can stem from simulated nucleotide conversions or sequencing errors. 

The plots show an increased rate of FP/FN reads in HISAT3N vs STAR.

HISAT3N should be less/not influenced by nucleotide conversions (as these are masked from the reference genome).
</div>

```{r}
calc_fcr_cvsu = function(tab) {
  tab %>% 
    group_by( mapper, classification, ftype, mappability) %>% 
    summarise(all=sum(count),
              cv_0=sum(count[(cv1==0) & (cv2==0)]), # reads with no tc conv
              cv_1=sum(count[(cv1==1) & (cv2==0)]), # reads with 1 tc conv
              cv_2=sum(count[cv2==1]), # reads with 2+ tc conv
              se_0=sum(count[(se1==0) & (se2==0)]), # reads with no seq err
              se_1=sum(count[(se1==1) & (se2==0)]), # reads with 1 seq err
              se_2=sum(count[(se2==1)])) %>% # reads with 2+ seq err
    pivot_wider(names_from=classification, 
                values_from=c(all, cv_0,cv_1,cv_2, se_0,se_1,se_2), 
                names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      cv_0_fn_frac=ifelse(cv_0_TP+cv_0_FN>0,cv_0_FN/(cv_0_TP+cv_0_FN),NA),
      cv_1_fn_frac=ifelse(cv_1_TP+cv_1_FN>0,cv_1_FN/(cv_1_TP+cv_1_FN),NA),
      cv_2_fn_frac=ifelse(cv_2_TP+cv_2_FN>0,cv_2_FN/(cv_2_TP+cv_2_FN),NA),
      se_0_fn_frac=ifelse(se_0_TP+se_0_FN>0,se_0_FN/(se_0_TP+se_0_FN),NA),
      se_1_fn_frac=ifelse(se_1_TP+se_1_FN>0,se_1_FN/(se_1_TP+se_1_FN),NA),
      se_2_fn_frac=ifelse(se_2_TP+se_2_FN>0,se_2_FN/(se_2_TP+se_2_FN),NA),
      # FP rate
      cv_0_fp_frac=ifelse(cv_0_TP+cv_0_FP>0,cv_0_FP/(cv_0_TP+cv_0_FP),NA),
      cv_1_fp_frac=ifelse(cv_1_TP+cv_1_FP>0,cv_1_FP/(cv_1_TP+cv_1_FP),NA),
      cv_2_fp_frac=ifelse(cv_2_TP+cv_2_FP>0,cv_2_FP/(cv_2_TP+cv_2_FP),NA),
      se_0_fp_frac=ifelse(se_0_TP+se_0_FP>0,se_0_FP/(se_0_TP+se_0_FP),NA),
      se_1_fp_frac=ifelse(se_1_TP+se_1_FP>0,se_1_FP/(se_1_TP+se_1_FP),NA),
      se_2_fp_frac=ifelse(se_2_TP+se_2_FP>0,se_2_FP/(se_2_TP+se_2_FP),NA)
  ) %>% 
#  filter_at(vars(tc_0_fn_frac, tc_1_fn_frac, tc_2_fn_frac), all_vars(!is.na(.))) %>% # values in all categories
  pivot_longer(cols=ends_with('frac')) %>%
  separate(name, into=c('cat','n_conv','class',NA), sep ='_')  %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
  mutate(n_conv=factor(ifelse(n_conv==2, '2+', as.character(n_conv)), levels=c('0','1','2+')))
}

fcr_cvsu = calc_fcr_cvsu(tx)


p1=fcr_cvsu %>% 
  filter(cat=='se', class=='fn') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('sequencing errors, FN') +
  ylab("#FN / (#TP + #FN)")
p2=fcr_cvsu %>% 
  filter(cat=='se', class=='fp') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('sequencing errors, FP') +
  ylab("#FP / (#TP + #FP)")
p3=fcr_cvsu %>% 
  filter(cat=='cv', class=='fn') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('nucleotide conversions, FN') +
  ylab("#FN / (#TP + #FN)")
p4=fcr_cvsu %>% 
  filter(cat=='cv', class=='fp') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('nucleotide conversions, FP') +
  ylab("#FP / (#TP + #FP)")
my_plot_grid(list(p1,p2,p3,p4), nrow=2, 'FN/FP fraction dependence on mismatches')

ggsave(paste0(params$out_dir, 'special_conv_unconv_reads.pdf'), width=12, height=10)
```
## MQ20 Mapping quality filtering

Demonstrate effect of mq20 filtering on coverage and mapping F1.

```{r}

comp_cov=function(a,b, grp_vars) {
  sel_vars=grp_vars[grp_vars!='classification']
  calc_coverage(a %>% group_by_at(grp_vars) ) %>% 
    select(any_of(c(sel_vars, 'value'))) %>% 
    left_join(
      calc_coverage(b %>% group_by_at(grp_vars) ) %>% 
        select(any_of(c(sel_vars, 'value'))),
      by=sel_vars, suffix = c(".mq0", ".mq20"),
    )
}

cov_comp_tx = comp_cov(tx, tx20, c('mapper', 'conversion_rate', 'fid', 'len', 'classification' ))
cov_comp_fx = comp_cov(fx, fx20, c('mapper', 'conversion_rate', 'fid', 'true_isoform', 'ftype', 'len', 'classification' )) 
# sanity check: 
#testthat::expect_that(cov_comp_tx %>% filter(value.mq20>value.mq0) %>% nrow(), equals(0))
#testthat::expect_that(cov_comp_fx %>% filter(value.mq20>value.mq0) %>% nrow(), equals(0))
#cov_comp_fx %>% mutate(comp=(value.mq0 > value.mq20) - (value.mq0 < value.mq20)) %>% count(comp)


p1 = cov_comp_tx %>% 
  pivot_longer(c(value.mq0, value.mq20), names_prefix='value.', names_to='mq') %>% 
  replace_na(list(value = 0)) %>% 
  ggplot(aes(x=mapper, y=value, fill=factor(mq))) + geom_boxplot() +
  scale_y_sqrt() +
  #facet_grid(conversion_rate~., scales = 'free') +
  ggtitle('Coverage over tx interval') + 
  xlab('') + ylab('coverage') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  guides(fill=guide_legend(title="Min mapping quality"))


p2 = cov_comp_fx %>% 
  pivot_longer(c(value.mq0, value.mq20), names_prefix='value.', names_to='mq') %>% 
  replace_na(list(value = 0)) %>% # some mq20 entries have no counts in any classification leading to NAs
  ggplot(aes(x=mapper, y=value, fill=factor(mq))) + geom_boxplot() +
  scale_y_sqrt() +
  ggtitle('Coverage per genomic feature') +
  facet_grid(true_isoform~ftype, scales = 'free') + 
  xlab('') + ylab('coverage') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  guides(fill=guide_legend(title="Min mapping quality"))

p3=cov_comp_fx %>% 
  group_by(mapper, conversion_rate, true_isoform, ftype ) %>% 
  summarise(mq0=sum(value.mq0),
            mq20=sum(value.mq20, na.rm = T),
            frac_fil=ifelse(mq0>0,(mq0-mq20)/mq0,0)) %>% 
  ggplot(aes(conversion_rate, frac_fil, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(true_isoform~ftype, scales = 'free') +
  ggtitle("Fraction of mq20 filtered reads per genomic feature")


perf_comp = tx %>% bind_rows(fx) %>% 
  group_by(mapper, conversion_rate, mappability, len, classification,true_isoform,ftype) %>% 
  calc_performance(conf$readlen) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
  filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
  ungroup() %>% 
  select(mapper, conversion_rate, mappability,true_isoform,ftype,F1.mq0=F1) %>% 
  left_join(
    tx20 %>% bind_rows(fx20) %>% 
    group_by(mapper, conversion_rate, mappability, len, classification,true_isoform,ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup() %>% 
    select(mapper, conversion_rate, mappability,true_isoform,ftype,F1.mq20=F1),
    by=c('mapper', 'conversion_rate', 'mappability', 'true_isoform','ftype')
  )

p4 = perf_comp %>% 
  pivot_longer(c(F1.mq0, F1.mq20), names_prefix='F1.', names_to='mq', values_to='F1') %>% 
  group_by(conversion_rate, mapper, mappability, true_isoform, ftype, mq) %>% 
  calc_ci(F1) %>% 
  ggplot(aes(conversion_rate, col.mean, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype+mq, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Mean F1 for mature isoforms per condition based on mq20/unfiltered read counts') 


p4 = perf_comp %>% 
  pivot_longer(c(F1.mq0, F1.mq20), names_prefix='F1.', names_to='mq', values_to='F1') %>% 
  group_by(conversion_rate, mapper, mappability, true_isoform, ftype, mq) %>% 
  calc_ci(F1) %>% 
  ggplot(aes(mapper, col.mean, col=mq, group=paste0(mapper,mq))) +
  geom_boxplot() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype+true_isoform, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Mean F1 for mature isoforms per condition based on mq20/unfiltered read counts') 

 my_plot_grid(list(p1,p2,p3,p4), labels = T, 'Coverage of mapping-quality filtered reads')

 
 
 
 
```

## Decay analysis

@see splice_sim_decay_analysis.Rmd

## sequencing strategy analysis

@see splice_sim_sequencing_strategies.Rmd

## Mismapped reads per chromosome

TODO
We know for every read where it originates from an where it maps to
Example analysis: where do we see large clusters of sequence similar regions. Plot #FP/FN per chrom. Chrom13 should have a peak due to histone cluster

```{r chrom_mismap, include=F, echo=F, eval=F}
```


## Mean mappability per genomic feature

<div class = "blue">
<b>Genomic mappability of genommic features.</b>
A) Violin plots of mean mappability for genomic features from the mouse dataset starified by gene type category. 
Mean mappability was calculated by averaging over a mm10 single-read umap mappability score created with kmer size 24.
B) Mean mappability vs feature length  for protein coding genes only.
</div>

```{r, include=F, echo=F, eval=F}
# top_gene_type_cat = m[['ga']] %>% count(gene_type) %>% arrange(desc(n)) %>% head(4) %>% pull(gene_type)
top_gene_type_cat=c('protein_coding', 'lincRNA', 'processed_pseudogene', 'other')
tab = m[['fx']] %>% select(tid, fid, ftype, mean_map, len) %>% 
  bind_rows(
    m[['tx']] %>% mutate(fid=tid) %>% select(tid, fid, ftype, mean_map, len)
  ) %>% 
  left_join(m[['ga']], by='tid') %>% 
  mutate(gene_type_cat=case_when( gene_type %in% !!top_gene_type_cat ~ as.character(gene_type),
                                  TRUE ~ 'other') ) %>% 
  mutate(gene_type_cat=factor(gene_type_cat, levels=!!top_gene_type_cat)) 

p1 = tab %>% 
  ggplot(aes(gene_type_cat, mean_map)) +
  geom_violin() +
  geom_hline(yintercept = c(0.2,0.9),  col="black",linetype="dotted") +
  facet_grid(ftype~.)

p2 = tab %>%
  filter(gene_type=='protein_coding')  %>% 
  ggplot(aes( mean_map, len/1000 )) +
  stat_binhex(bins=50) + scale_fill_gradientn("", trans = "log", colours =
                                                rev(rainbow(5, end = 4/6))) +
  geom_vline(xintercept = c(0.2,0.9),  col="black",linetype="dotted")  +
  facet_grid(ftype~.) +
  scale_y_log10() +
  ylab("feature length [kb]")

my_plot_grid(list(p1,p2), labels = T, 'mappability ')
```

# Examples

```{r, include=F, echo=F, eval=F}

gene_name='Actb'
tid=gn2tid(gene_name)
label=paste0(gene_name,':', tid)

intron_mappability %>% 
  filter(tid==!!tid) %>% 
  left_join(m[['sj']], by=c('tid', 'fid')) %>% 
  ggplot(aes(factor(rnk), filtered)) + geom_point() + facet_grid(mapper~filter_type)

sfrac %>% 
  filter(tid==!!tid) %>% 
  select(tid, mapper, conversion_rate, filter_type, true_spliced, found_spliced, found_spliced_fil ) %>% 
  pivot_longer(-c(tid, mapper, conversion_rate, filter_type)) %>% 
  ggplot(aes(conversion_rate, value, col=name)) +
    geom_point() +
    facet_grid(mapper~filter_type)

p1=calc_fcr_cvsu(tx %>% filter(fid==!!tid)) %>% 
  ggplot(aes(n_conv, value, col=mapper, group=paste0(mapper,cat))) +
  geom_line() +
  facet_grid(cat~mapper+class, scales = 'free')  +
  ggtitle('FCR',label)

```

# Write results tables
```{r}

# build summary table per tx
tab_summary =
  results[['map_tx_tab']] %>% select(gene_name, tid, mappability,
                                     map_best_no_conv=best_mapper_no_conv, 
                                     map_best_conv=best_mapper_conv) %>% 
  full_join(
    results[['fcr_tx_tab']] %>% select(gene_name, tid, 
                                       fcr_best=best_mapper), 
    by=c('gene_name', 'tid' )) %>% 
  full_join(
    results[['spl_tx_tab']] %>% select(gene_name, tid, 
                                       spl_best=best_mapper_fmat), 
    by=c('gene_name', 'tid' )) 
  
results=c(list('summary'=tab_summary), results)

tab_summary %>% 
  rename(MAP=map_best_no_conv, MAP_CONV=map_best_conv, FCR=fcr_best, FMAT=spl_best) %>% 
  pivot_longer(c(MAP, MAP_CONV, FCR, FMAT), values_to='mapper' ) %>% 
  group_by(name, mapper, mappability) %>% 
  count() %>% 
  mutate(name=factor(name, levels=c('MAP', 'MAP_CONV', 'FCR', 'FMAT')),
         mapper=factor(toupper(mapper), levels=c('BOTH', 'STAR', 'HISAT3N'))) %>% 
  ggplot(aes(mapper, n, fill=mapper)) +
    geom_bar(stat='identity') +
    facet_grid(mappability~name, scales = 'free') +
    ggtitle('Best mapper per category') +
    scale_x_discrete(drop = FALSE) +
    scale_fill_discrete(drop=FALSE) +
    ylab("number of transcripts") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggsave(paste0(params$out_dir, 'Best_mapper_summary.pdf'), width=12, height=10)

# write excel result file
write_xlsx(results, path=paste0(params$out_dir, 'map.xlsx'))
```