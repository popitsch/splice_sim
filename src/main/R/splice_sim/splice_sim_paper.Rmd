---
title: "splice_sim_paper.Rmd"
author: "niko.popitsch@imba.oeaw.ac.at"

documentclass: article
fontsize: 10pt
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 14
    fig_height: 10
    fig_caption: true
    df_print: paged
  pdf_document:
    fig_width: 12
    fig_height: 10
    fig_caption: true
params:
    splice_sim_config:
       value: "/Volumes/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/splice_sim.config.json"
    out_dir:
       value: "/Volumes/groups/ameres/Niko/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/analysis/"
---
<style type="text/css">
body, td {
   font-size: 10px;
}
code.r{
  font-size: 10px;
}
pre {
  font-size: 10px
}
div.blue pre { background-color:lightblue; }
div.blue pre.r { background-color:blue; }
</style>

# INIT

```{r setup, include=FALSE}
require(data.table)
require(tidyr)
require(dplyr)
require(ggplot2)
require(scales)
require(rjson)
require(stringr)
require(VGAM)
require(cowplot)
require(arrow)
require(tictoc)
require(ggpubr)
require(minpack.lm)
require(readr)
require(testthat)
require(RColorBrewer)
require(skimr)
require(ggforce)
# NB install arrow with snappy on Rstudio server
# Sys.setenv(ARROW_WITH_SNAPPY = "ON")
# Sys.setenv(NOT_CRAN="true")
# Sys.setenv(LIBARROW_BINARY="FALSE")
# install.packages("arrow", repos = "https://arrow-r-nightly.s3.amazonaws.com")

# to ensure stripping '\0' (nul) from character vector
options(arrow.skip_nul = TRUE)

# global theme
ggplot2::theme_set(theme_light())

# enable tidylog (has overhead!)
#require(tidylog)
# turn tidylog off
options("tidylog.display" = list()) 

# load data from TSV
load_table = function(dataF, append="", header=T, nrows=Inf) {
  dataF = as.character(paste0(dataF, append))
  print(paste("Loading", dataF))
  if ( endsWith(dataF, ".gz") ) {
    return(fread(cmd=paste('gunzip -c', dataF), header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  } else {
    return(fread(dataF, header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  }
}

# multiple plots with single title
my_plot_grid = function(plots, main, ncol=NULL, nrow=NULL, labels=NULL) {
  
  if (!is.null(labels)){
    if (labels==T) { labels=LETTERS[1:length(plots)] }
  }
  plot_row=plot_grid(plotlist=plots, ncol=ncol, nrow=nrow, labels=labels)
  title <- ggdraw() + draw_label( main, fontface = 'bold', x = 0, hjust = 0 ) + theme(plot.margin = margin(0, 0, 0, 7))
  return (plot_grid(title, plot_row, ncol = 1, rel_heights = c(0.1, 1)))
}

# calculate confidence interval (ci),  a measure of precision 
# call with mtcars %>% calc_ci(mpg) or mtcars %>% group_by(cyl) %>% calc_ci(mpg)
# plot with ...  %>% ggplot(aes(x=cyl, y=col.mean)) + geom_line() + geom_ribbon(aes(ymin=col.lower, ymax=col.upper), alpha=0.1 ...)
calc_ci = function(d, col, min_lower_ci=NA, max_upper_ci=NA) {
  ret = d %>% summarise(
            col.mean := mean({{col}}, na.rm = TRUE),
            #col.median := median({{col}}, na.rm = TRUE),
            col.sd = sd({{col}}, na.rm = TRUE),
            col.n = n(),
            .groups = 'drop') %>%
  mutate(stderr = col.sd / sqrt(col.n),
         col.lower = col.mean - qt(1 - (0.05 / 2), col.n - 1) * stderr,
         col.upper = col.mean + qt(1 - (0.05 / 2), col.n - 1) * stderr) %>% 
  ungroup() %>% 
  mutate(col.lower = pmax(min_lower_ci, col.lower, na.rm=T),
         col.upper = pmin(max_upper_ci, col.upper, na.rm=T))
  return (ret)
}

# calculate interquartile range (iqr), a measure of dispersion
# call with mtcars %>% calc_iqr(mpg) or mtcars %>% group_by(cyl) %>% calc_iqr(mpg)
# plot with  ... %>% ggplot(aes(x=cyl, y=col.median)) + geom_line() + geom_ribbon(aes(ymin=col.lower, ymax=col.upper), alpha=0.1 ...)
calc_iqr = function(d, col) {
  d %>% summarise(
            col.median = median({{col}}, na.rm = T),
            #col.mean = mean({{col}}, na.rm = T),
            col.upper = quantile({{col}}, .75, na.rm = T),
            col.lower = quantile({{col}}, .25, na.rm = T),
            col.n = n(),
            .groups = 'drop')
}

#
# write result tibble to BED file
#
write_bed = function(dat, bed_file, title, header=F) {
  sink(bed_file)
  cat(paste0("track name=",title," description=\"",title,"\" useScore=1 itemRgb=\"On\"\n"))
  sink()
  dat %>% write_tsv( bed_file, col_names = F, append = T ) 
}

# calculates performance and coverage on grouped data.
# required columns: count, classification, len
calc_performance=function(tab, readlen) {
  tab %>% 
    summarise(count=sum(count)) %>% 
    pivot_wider(names_from=classification, values_from=count, names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      read_count=TP+FN,
      cov=read_count*!!readlen/len,
      precision=ifelse(TP+FP>0, TP/(TP+FP), NA),
      recall=ifelse(TP+FN>0,TP/(TP+FN), NA),
      F1=ifelse((2*TP+FP+FN)>0,2*TP/(2*TP+FP+FN),NA)
  ) 
}


```


# data

```{r data, include=F, echo=F, cache=T}

home_dir=paste0(dirname(params$splice_sim_config),'/')
conf=fromJSON(paste(readLines(params$splice_sim_config), collapse=""))

#home_dir='/Users/niko.popitsch/Desktop/data/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/'


# results files
data_file=paste0(home_dir,'/results/data.rds')
meta_file=paste0(home_dir,'/results/meta.rds')

if (file.exists(data_file)) {
  tic("load data")
  d=readRDS(data_file)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(meta_file)) {
  tic("load metadata")
  m=readRDS(meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}


# to calc performance data
# d[['fx']] %>% 
#   group_by(fid,mapper,conversion_rate,classification,len,gene_name,num_exons,ftype) %>% 
#   calc_performance(conf$readlen) 

# to add meta data
# %>% 
#   left_join(m[['tx']], by=c('fid'='tid')) %>% # NB too-short tx are lost
#   left_join(m[['ga']], by=c('fid'='tid')) 

```


## QC

### NA counts

Calculate and plot the fraction of NA counts per table/column

```{r non_na, include=T, echo=F, cache=T}
# count non-NA values per column for all passed tables
count_na_per_column = function(tables) {
 counts=tibble()
 for (name in names(tables)) {
    print(name)
    tab=tables[[name]]
    nr=nrow(tab)
    if (!is.null(nr)) {
      if (nr>0) {
        counts=counts %>% rbind(
          tab %>% select(everything()) %>% summarise_all(funs(sum(is.na(.)))) %>% mutate(table=!!name) %>% collect() %>% pivot_longer(-table) %>% mutate(nr=!!nr, frac=value/nr)
        )
      }
    }
  }
  return (counts)
}

non_na_counts = count_na_per_column(c(setNames(d, paste0('d_',names(d))),setNames(m, paste0('m_',names(m)))) )
ggplot(non_na_counts, aes(x=name, y=frac)) +
  geom_bar(stat='identity') +
  facet_wrap(table~., scales = 'free') +
  ggtitle("Fraction of NA counts per table column") + 
  xlab("") + ylab("") +
  ylim(0,1) +
  coord_flip() 

```

### Missing tids

Some of the originally configured transcript ids are missing from result data. 
This is either because 
- there were no reads simulated as the annotation is smaller than read-size and there are no (longer) overlapping transcripts
- annotations are very long (e.g., Kcnip1 or Cmss1)

```{r missing_tids, include=T, echo=F, cache=T}
# how many tx did we recover
found_tids=unique(d[['tx']] %>% pull(fid))
missing_tids=setdiff(m[['all_tids']],found_tids)
print(paste0("We have data for ", length(found_tids), '/', length(m[['all_tids']]), " tx"))

# what are the missing tx?
missing_tx=load_table('/groups/ameres/Niko/projects/Ameres/splicing/data/slamstr/pooled.mm10.all/pooled.mm10.all.Slamstr.stats.trans.final.tsv.gz') %>% 
  select(tid=transcript_id, gene_type, len, ilen) %>% 
  filter(tid %in% m[['all_tids']]) %>% 
  mutate(cat=ifelse(tid %in% found_tids, 'recovered','missing')) 
p1=missing_tx %>% ggplot(aes(x=factor(cat), y=len)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Length distribution of recovered vs missing tx") +
  geom_hline(yintercept = conf$readlen, col='red')
p2=missing_tx %>% ggplot(aes(x=factor(cat), y=ilen)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Intron Length distribution of recovered vs missing tx") +
  geom_hline(yintercept = conf$max_ilen, col='red')
# did we recover all reads?
p3 = d[['tx']] %>% group_by(mapper, conversion_rate, classification) %>% summarise(count=sum(count)) %>% pivot_wider(names_from=classification, values_from=count) %>% 
mutate(all=TP+FN) %>% ggplot(aes(conversion_rate, all, fill=mapper)) + geom_bar(stat='identity', position='dodge') + ggtitle('read counts per mapper/condition')

my_plot_grid(list(p1,p2,p3), labels=T, 'QC only', nrow = 1)

```


### Comparison of counts for unspliced tx

```{r unspliced_counts, include=T, echo=F, cache=T}
tab = d[['tx']] %>% 
  left_join(m[['tx']], by=c('fid'='tid')) %>% # NB too-short tx are lost
  filter(rnk==1, conversion_rate=='0.1') %>% 
  group_by(fid, mapper, true_isoform, classification, mappability) %>% 
  summarise(count=sum(count)) %>% 
  pivot_wider(names_from = classification, values_from=count) %>% 
  mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
  mutate(F1=ifelse((2*TP+FP+FN)>0,2*TP/(2*TP+FP+FN),NA)) %>% 
  select(fid,mapper,true_isoform,F1,FP,FN,TP,FP_raw,mappability) %>% 
  pivot_wider(names_from = true_isoform, values_from = c(F1,FP,FN,TP,FP_raw)) %>% 
  mutate(f1_diff=F1_mat-F1_pre) 
  
p1 = tab %>% ggplot(aes(mapper, f1_diff)) + geom_boxplot() + 
  facet_wrap(mappability~.) +
  geom_hline(yintercept = 0, col='red') +
  ggtitle("Difference in F1 value between mat/pre for unspliced transcripts. Should be zero!") 

p2 = tab %>% ggplot(aes(x=f1_diff)) + geom_density() + ggtitle("Difference in F1 value between pre/mat for unspliced transcripts. Should be zero!") +
  facet_wrap(mapper~.) +
  geom_vline(xintercept = 0, col='red')

p3 = tab %>% ggplot(aes(x=FP_mat, y=FP_pre, col=mappability, alpha=0.1)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~.)
p4 = tab %>% ggplot(aes(x=FN_mat, y=FN_pre, col=mappability, alpha=0.1)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~.)
p5 = tab %>% ggplot(aes(x=TP_mat, y=TP_pre, col=mappability, alpha=0.1)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~.)
p6 = tab %>% ggplot(aes(x=FP_raw_mat, y=FP_raw_pre, col=mappability, alpha=0.1)) + geom_point() + scale_x_sqrt() + scale_y_sqrt() + facet_wrap(mapper~.)

my_plot_grid(list(p1,p2,p3,p4,p5,p6), main="QC: comparing isoform performance of unspliced transcripts (cr=0.1)") 

```

# Tx / Fx
## Coverage

- The target coverage is ~50X per isoform, i.e., 100X overall
- There is an edge effect as reads that overlap with 1bp are counted for their full length when coverage is calculated.
  This could explain the increased mean coverage for exons and introns. 
  For exons this effect is a bit reduced as the 1st/last exon also has an edge effect as we don't simulate reads that overlap the tx edges.

<div class = "blue">
<b>Coverage of simulated/mapped reads per isoform/genomic feature.</b>
A) Coverage distributions calculated from unconverted reads only (conversion rate = 0). 
   Both mappers have problems with spliced read mapping indicated by reduced coverage of spliced reads (panel mat/exon)
   and increased coverage of mature isoform reads that were false-positively mapped to introns (panel mat/intron). 
   Presumably, most of these reads are overlapping the splice junctions.
B) Mean coverage per conversion rate. 
   STAR shows decreased coverage of spliced reads with increasing conversion rates while HISAT3N is unaffected by this.
Note that deviations of the configured ~100X coverage for this 1:1 mix of premature/mature isoforms presumably stems from edge effects of the coverage
calculation that does not take partial read overlap into account. Coverage thresholds 0,50,100 are indicated by grey horizontal lines.
</div>


```{r coverage, include=T, echo=F, cache=T}
calc_coverage = function(grp_tab) {
  grp_tab %>% 
      summarise(count=sum(count)) %>% 
      pivot_wider(names_from=c(mapper,classification), values_from=count, names_sort=T) %>% 
      mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
      filter(len>conf$readlen) %>% # filter too-short introns as this will lead to wrong coverage calc. Example: ENSMUST00000116560.2_in5
      mutate(
        simulated=(HISAT3N_TP+HISAT3N_FN)*!!conf$readlen/len, # same as simulated_star!
        HISAT3N=(HISAT3N_TP+HISAT3N_FP)*!!conf$readlen/len,
        STAR=(STAR_TP+STAR_FP)*!!conf$readlen/len,
    ) %>% pivot_longer(c(simulated, HISAT3N, STAR), names_to='mapper') %>% 
    mutate(mapper=factor(mapper, levels=c('simulated', 'HISAT3N', 'STAR')),
           is_converted=ifelse(conversion_rate==0,'no conversions', 'converted reads')) %>% 
    ungroup()
}

hlines=tribble(
  ~y,  ~cat,
  0,   1,
  50,  2,
  100, 3
)
tx = d[['tx']] %>% left_join(m[['tx']], by=c('fid'='tid')) 
fx = d[['fx']] %>% left_join(m[['fx']], by='fid') 

p1 = calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  facet_grid(is_converted~., scales = 'free') +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage over tx interval') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification )) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p3 = calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, ftype, len, classification )) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p4 = calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, true_isoform, len, classification ) ) %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per isoform') +
  facet_grid(is_converted~true_isoform, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

my_plot_grid(list(p1,p2,p3,p4), nrow=2, labels=T, 'QC: Coverage for converted and unconverted reads')

# final

tab = calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification ))
p1 = tab %>% 
  filter(is_converted=='no conversions') %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = tab %>% group_by(conversion_rate, ftype, true_isoform, mapper) %>% calc_ci(value) %>% 
  ggplot(aes(x=conversion_rate, y=col.mean, col=mapper, group=mapper)) + 
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean coverage per condition') +
  facet_grid(.~true_isoform+ftype)

my_plot_grid(list(p1,p2), labels=T, 'Coverage per mapper', nrow = 1)


# calc_coverage(d[['tx']] %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% group_by(conversion_rate,mapper) %>% summarise(m=mean(value)) %>% ggplot(aes(conversion_rate,m,fill=mapper)) + geom_bar(stat='identity', position = 'dodge') + ggtitle('Mean tx coverage per mapper and condition')

# NOTE: why is intron/pre coverage so high?
# I think this is because of an edge effect at intron/exon boundaries. Reads that overlap only 1 bp with intron are counted for their full rl. 
# The longer the intron, the less this influence gets:
# tab %>% filter(conversion_rate==0, mapper=='simulated') %>% ggplot(aes(len, value)) + geom_point() + facet_wrap(ftype~true_isoform, scales='free') + geom_vline(xintercept = 100, col='red')
# for exons, this effect is reduced by the edge effect on the 1st and last exon:
#tab %>% filter(conversion_rate==0, mapper=='simulated', ftype=='exon') %>% left_join(m[['fx']]) %>% mutate(is_edge=(rnk==1 | rnk==tx_rnk)) %>% 
#  ggplot(aes(x=is_edge, y=value)) + geom_boxplot() + facet_wrap(ftype~true_isoform, scales='free') 

```


## Performance

<div class = "blue">
<b>Mapping performance per conversion rate.</b>
Precision, recall and F1 score per feature type (tx: transcript), stratified by originating isoform (pre: premature, unspliced isoform; mat: mature, fully spliced isoform) and standard genomic mappability. 
Performance drops with increasing conversion rate for STAR but not HISAT3N.
</div>

```{r perf, include=T, echo=F, cache=T}
perf = tx %>% 
  bind_rows(
    fx %>% select(-rnk) %>% rename(rnk=tx_rnk) #mappability=tx_mappability; we could also use tx_mappability here?
  ) %>% 
  group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
           num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
  calc_performance(conf$readlen) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
  filter(!(ftype=='intron' & true_isoform=='mat')) # undefined and always 0!
  
perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_ci(precision) %>% 
  ggplot(aes(conversion_rate, col.mean, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Mean precision per condition') 

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_ci(recall) %>% 
  ggplot(aes(conversion_rate, col.mean, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Mean recall per condition') 

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_ci(F1) %>% 
  ggplot(aes(conversion_rate, col.mean, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Mean F1 per condition') 


```
### Correlation of F1 and genomic mappability

```{r, include=T, echo=F, cache=T}

perf %>% 
  #filter(conversion_rate==0) %>% 
  ggplot(aes(mean_map, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("mean genomic mappability") +
  ggtitle('Mean mappability vs F1') 

perf %>% 
  filter(conversion_rate==0) %>% 
  ggplot(aes(GC, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("GC%") +
  ggtitle('GC vs F1') 

perf %>% 
  filter(conversion_rate==0) %>% 
  ggplot(aes(rnk, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("number of exons") +
  ggtitle('Number of exons in tx vs F1') 

perf %>% 
  filter(conversion_rate==0.1) %>% 
  ggplot(aes(frac_convertible, F1, alpha=0.1)) +
  stat_binhex(bins=50) + scale_fill_gradientn("", colours = rev(rainbow(5, end = 4/6))) +
  geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted")  +
  facet_grid(true_isoform+mapper~ftype) +
  ylab("F1") + xlab("frac_convertible") +
  ggtitle('frac_convertible vs F1') 


# Does convertibility influence performance? Some effect seen for low mappability  
perf %>% 
  filter(ftype=='exon') %>% 
  group_by(conversion_rate, mapper, mappability, ftype, true_isoform, convertibility) %>% 
  calc_ci(F1) %>% 
  ggplot(aes(conversion_rate, col.mean, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~convertibility, scales = 'free', labeller = label_both) +
  ylab("") +
  ggtitle('Mean exonic F1 per convertibility class') 

```
## FCR


```{r, include=T, echo=F, cache=T}
fcr = tx %>% 
    bind_rows(fx) %>% 
    group_by(fid, mapper, conversion_rate, classification, true_isoform, mappability, ftype) %>% 
    summarise(all=sum(count), 
              tc1=sum(count[cv1==1]), 
              tc2=sum(count[cv2==1])) %>% 
    pivot_wider(names_from=classification, values_from=c(all, tc1, tc2), names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      all_true =  all_TP+all_FN,
      all_found = all_TP+all_FP,
      tc1_true =  tc1_TP+tc1_FN,
      tc1_found = tc1_TP+tc1_FP,
      tc2_true =  tc2_TP+tc2_FN,
      tc2_found = tc2_TP+tc2_FP,
      true_fcr1 = ifelse(all_true>0,tc1_true/all_true,0),
      found_fcr1 = ifelse(all_found>0,tc1_found/all_found,0),
      true_fcr2 = ifelse(all_true>0,tc2_true/all_true,0),
      found_fcr2 = ifelse(all_found>0,tc2_found/all_found,0)
  ) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron')))

# fcr %>% 
#   filter(mapper=='STAR') %>% 
#   ggplot(aes(conversion_rate, true_fcr1, alpha=0.1)) +
#   geom_boxplot() +
#   facet_grid(true_isoform~ftype+mappability) +
#   ggtitle("QC: Simulated fcr per conversion rate")

fcr_perf = fcr %>%
  select(fid, conversion_rate,true_isoform,ftype,mappability,true_fcr1, found_fcr1) %>% 
  ungroup() %>% 
  pivot_wider(names_from=mapper, values_from=c(true_fcr1, found_fcr1)) %>% 
  mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>%   # replace NA with 0; NA are resulting from mat not having introns. So if there are no FP values then there are no entries!
  rename(simulated=true_fcr1_HISAT3N, HISAT3N=found_fcr1_HISAT3N, STAR=found_fcr1_STAR) %>%
  select(-true_fcr1_STAR) %>% 
  mutate(diff_HISAT3N=HISAT3N-simulated, 
         diff_STAR=STAR-simulated,
         best_mapper=ifelse(diff_HISAT3N<diff_STAR, 'HISAT3N', ifelse(diff_STAR<diff_HISAT3N,'STAR','BOTH'))
         )
```

<div class = "blue">
<b>Fraction of converted reads.</b>
Fraction of converted reads (fcr), stratified by feature type and originating isoform.
Note that HISAT3N and STAR tend to slightly over- respctively underestimate FCR in exonic regions.
The non-zero FCR for mature introns results from false-positive intronic reads.

</div>

```{r fcr_perf}

fcr_perf %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N')))
  group_by(conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(true_isoform~ftype)


```

<div class = "blue">
<b>Best mapper counts.</b>
Number of times a mapper 

</div>

```{r fcr_perf}
fcr_perf %>% group_by(conversion_rate, best_mapper, ftype, true_isoform) %>% 
  summarise(n = n()) %>%
  mutate(frac = n / sum(n)) %>% 
  ggplot(aes(conversion_rate, frac, fill=best_mapper)) + geom_bar(stat='identity', position = 'dodge') +
  ggtitle('Best mapper wrt. FCR') +
  facet_grid(ftype~true_isoform)

fcr_perf %>% 
  pivot_longer(c(diff_HISAT3N, diff_STAR)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  scale_y_continuous(trans=scales::pseudo_log_trans(base = 10))
```

# SJ

```{r, include=T, echo=F, cache=T}

sj = d[['sj']] %>% 
  group_by(mapper, conversion_rate, class_type, fid, true_isoform, classification) %>% 
  summarise(count=sum(count))

# QC: check classification of pre reads  
p1 = sj %>% filter(mapper=='HISAT3N') %>% group_by(true_isoform, classification, class_type) %>% summarise(count=sum(count)) %>% 
  ggplot(aes(classification, count, fill=true_isoform)) + geom_bar(stat='identity', position='dodge') + facet_grid(class_type~true_isoform) +
  ggtitle('HISAT3N')
p2 = sj %>% filter(mapper=='STAR') %>% group_by(true_isoform, classification, class_type) %>% summarise(count=sum(count)) %>% 
  ggplot(aes(classification, count, fill=true_isoform)) + geom_bar(stat='identity', position='dodge') + facet_grid(class_type~true_isoform) +
  ggtitle('STAR')
my_plot_grid(list(p1,p2), 'QC: premature reads should only be classified as acc/don\nThere cannot be TP/FN pre spl reads')
```


<div class = "blue">
<b>Intron filtering statistics.</b>
Number of filtered introns including or excluding converted datasets.
</div>

```{r, include=T, echo=F, cache=T}
sj_per = sj %>% 
  group_by(mapper, conversion_rate, fid, class_type, classification) %>% 
  summarise(count=sum(count)) %>% 
  pivot_wider(names_from=c(class_type, classification), values_from=count) %>% 
  ungroup() %>% 
  mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
  left_join(m[['sj']], by='fid') %>% 
  mutate(
    spl_pre=ifelse(spl_TP+spl_FP>0, spl_TP/(spl_TP+spl_FP), NA),
    spl_rec=ifelse(spl_TP+spl_FN>0, spl_TP/(spl_TP+spl_FN), NA),
    spl_F1=ifelse((2*spl_TP+spl_FP+spl_FN)>0,2*spl_TP/(2*spl_TP+spl_FP+spl_FN),NA),
    acc_pre=ifelse(acc_TP+acc_FP>0, acc_TP/(acc_TP+acc_FP), NA),
    acc_rec=ifelse(acc_TP+acc_FN>0, acc_TP/(acc_TP+acc_FN), NA),
    acc_F1=ifelse((2*acc_TP+acc_FP+acc_FN)>0,2*acc_TP/(2*acc_TP+acc_FP+acc_FN),NA),
    don_pre=ifelse(don_TP+don_FP>0, don_TP/(don_TP+don_FP), NA),
    don_rec=ifelse(don_TP+don_FN>0, don_TP/(don_TP+don_FN), NA),
    don_F1=ifelse((2*don_TP+don_FP+don_FN)>0,2*don_TP/(2*don_TP+don_FP+don_FN),NA),
    true_mat=spl_FN+spl_TP,
    found_mat=spl_FP+spl_TP,
    true_pre=don_FN+don_TP+acc_FN+acc_TP,
    found_pre=don_FP+don_TP+acc_FP+acc_TP,
    true_spliced=ifelse(true_pre>0,true_mat/(true_pre+true_mat), NA),
    found_spliced=ifelse(found_pre>0,found_mat/(found_pre+found_mat), NA),
    spliced_diff=abs(true_spliced-found_spliced)
  )  %>% mutate(spliced_diff_rnk = dense_rank(spliced_diff)) # rank of difference to true spliced value. Bad introns have higher ranks

# ===============================================
# Calculate bad/filtered introns
# ===============================================
min_spliced_diff = 0.1 # filter SJ only if diff to true value is greater than this value
min_remaining_readcount = 100 # filter SJs util this remaining_readcount
intron_mappability = sj_per %>% 
    group_by(tid, mapper, conversion_rate) %>% 
    arrange(spliced_diff_rnk) %>% 
    mutate(read_sum=cumsum(found_mat+found_pre)) %>% 
    select(tid, mapper, conversion_rate, fid, spliced_diff_rnk, spliced_diff, 
           true_pre, true_mat, found_pre, found_mat, read_sum) %>% 
    arrange(desc(spliced_diff_rnk)) %>% # sort per tx by decreasing intron rnk, i.e.,bad introns first
    mutate(remaining_reads=lead(read_sum, default=0)) %>% # remaining reads after removing the current intron
    mutate(low_map = (is.na(spliced_diff) | 
                        (spliced_diff>!!min_spliced_diff & remaining_reads>!!min_remaining_readcount))) %>% 
    group_by(mapper, tid, fid) %>% summarise(
      include_converted=ifelse(sum(low_map)>sum(!low_map),1,0),   # filter because in most conditions it is filtered
      unconverted_only=low_map[conversion_rate==0]  # filter because in cond0 it is filtered
      ) %>% 
  ungroup() %>% 
  pivot_longer(c(include_converted, unconverted_only), names_to = 'filter_type', values_to='filtered')


# ===============================================
# QC plots
# ===============================================

# plot distribution of low_mappability introns
levs=c('not filtered','filtered in STAR', 'filtered in HISAT3N', 'filtered in both')
intron_mappability %>% 
  pivot_wider(names_from=mapper, values_from = filtered, id_cols = c('tid', 'fid', 'filter_type')) %>% 
  mutate(lab=case_when(
    (HISAT3N) & (STAR) ~ 'filtered in both',
    (!HISAT3N) & (STAR) ~ 'filtered in STAR',
    (HISAT3N) & (!STAR) ~ 'filtered in HISAT3N',
    T ~ 'not filtered'
    )) %>% 
  count(filter_type, lab) %>% 
  ggplot(aes(x=lab, y=n, fill=lab)) +
  scale_fill_manual(name = "lab",values = setNames(brewer.pal(length(levs),"Set1"), levs)) +
  geom_bar(stat='identity') +
  facet_wrap(filter_type~.) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggtitle('Filter results per intron') 
  
```

```{r, include=T, echo=F, cache=T}
# Table to compare frac_spliced w/wo intron filtering
sfrac = sj_per %>% 
  left_join(intron_mappability, by=c('mapper', 'fid', 'tid' )) %>% 
  filter(filter_type=='include_converted') %>%  # TC part
  group_by(tid, mapper, conversion_rate, filter_type, tx_mappability) %>% 
  summarise(true_mat=sum(spl_FN)+sum(spl_TP),
            found_mat=sum(spl_FP)+sum(spl_TP),
            true_pre=sum(don_FN)+sum(don_TP)+sum(acc_FN)+sum(acc_TP),
            found_pre=sum(don_FP)+sum(don_TP)+sum(acc_FP)+sum(acc_TP),
            # --- filtered ----
            true_mat_fil=sum(spl_FN[!filtered])+sum(spl_TP[!filtered]),
            found_mat_fil=sum(spl_FP[!filtered])+sum(spl_TP[!filtered]),
            true_pre_fil=sum(don_FN[!filtered])+sum(don_TP[!filtered])+sum(acc_FN[!filtered])+sum(acc_TP[!filtered]),
            found_pre_fil=sum(don_FP[!filtered])+sum(don_TP[!filtered])+sum(acc_FP[!filtered])+sum(acc_TP[!filtered]),
            n_fil=sum(filtered, na.rm = T),
            .groups = 'drop'
         ) %>% 
  bind_rows(
    sj_per %>% 
      left_join(intron_mappability, by=c('mapper', 'fid', 'tid' )) %>% 
      filter(filter_type=='iunconverted_only', conversion_rate==0) %>%  # no-TC part
      group_by(tid, mapper, conversion_rate, filter_type, tx_mappability) %>% 
      summarise(true_mat=sum(spl_FN)+sum(spl_TP),
                found_mat=sum(spl_FP)+sum(spl_TP),
                true_pre=sum(don_FN)+sum(don_TP)+sum(acc_FN)+sum(acc_TP),
                found_pre=sum(don_FP)+sum(don_TP)+sum(acc_FP)+sum(acc_TP),
                # --- filtered ----
                true_mat_fil=sum(spl_FN[!filtered])+sum(spl_TP[!filtered]),
                found_mat_fil=sum(spl_FP[!filtered])+sum(spl_TP[!filtered]),
                true_pre_fil=sum(don_FN[!filtered])+sum(don_TP[!filtered])+sum(acc_FN[!filtered])+sum(acc_TP[!filtered]),
                found_pre_fil=sum(don_FP[!filtered])+sum(don_TP[!filtered])+sum(acc_FP[!filtered])+sum(acc_TP[!filtered]),
                n_fil=sum(filtered, na.rm = T),
                .groups = 'drop'
             )
  ) %>% 
  filter( found_mat_fil+found_pre_fil>!!min_remaining_readcount ) %>% # drop if due to filtering the overall readcount became too low
  mutate(
         true_spliced=ifelse(true_pre>0,true_mat/(true_pre+true_mat), NA),
         found_spliced=ifelse(found_pre>0,found_mat/(found_pre+found_mat), NA),
         found_spliced_fil=ifelse(found_pre_fil>0,found_mat_fil/(found_pre_fil+found_mat_fil), NA),
  ) %>% 
  mutate(diff_spliced=true_spliced-found_spliced,
         diff_spliced_fil=true_spliced-found_spliced_fil) %>% 
  mutate(improvement=abs(diff_spliced) - abs(diff_spliced_fil)) %>% 
  left_join(m[['tx']] %>% select(tid, n_overlapping, rnk), by='tid') %>% 
  left_join(m[['ga']] %>% select(tid, gene_type), by='tid')

sfrac_ntx = sfrac %>% summarise(n_tids=n_distinct(tid)) %>% pull(n_tids)
sfrac_ntx2 = sfrac %>% filter(n_fil>0) %>% summarise(n_tids=n_distinct(tid)) %>% pull(n_tids)
print(glue::glue('We have data for {sfrac_ntx} tx or which {sfrac_ntx2} ({prettyNum(sfrac_ntx2*100/sfrac_ntx, digits=2)}%) have at  least 1 filtered intron) ')) 

# plot difference to true fractions
sfrac %>% 
  select(mapper, tid, conversion_rate, filter_type, n_fil, improvement, 
         tx_mappability, n_overlapping) %>% 
  filter(n_fil > 0) %>% 
  mutate(is_overlapping=ifelse(n_overlapping>0,'overlapping tx', 'non-overlapping tx')) %>% 
  ggplot(aes(x=conversion_rate, y=improvement, fill=filter_type)) +
    geom_boxplot(outlier.colour = 'grey') +
    facet_grid(tx_mappability~mapper) +
    geom_hline(yintercept = 0, col='black') +
    ggtitle('Improvement per mapper for tx with at least one filtered intron')

sfrac %>%
  filter(n_fil>0, n_overlapping==0, gene_type=='protein_coding') %>%
  mutate(is_overlapping=ifelse(n_overlapping>0,'overlapping tx', 'non-overlapping tx')) %>%
  mutate(frac_filtered=round(n_fil/(rnk-1),1)) %>%
  group_by(mapper, frac_filtered, tx_mappability, is_overlapping, conversion_rate, filter_type) %>% 
  calc_iqr(improvement) %>%
  ggplot(aes(x=frac_filtered, y=col.median, col=mapper, group=mapper)) +
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=3, alpha=0.05) +
  geom_line() +
  geom_hline(yintercept = 0, col='black') +
  facet_grid(tx_mappability~paste0(is_overlapping,', cr=',conversion_rate, ', ft=', filter_type)) +
  ggtitle('Improvement of frac_mature estimate per fraction introns filtered',
          paste0('protein_coding only'))

```

## SJ: best tx per mapper
- calc for each tx: which mapper has smallest diff to sim truth after correction

```{r sj_corr_best_tx, include=T, echo=F, cache=T}
best_mapper_fmat = sfrac %>% 
    select(mapper, tid, conversion_rate,filter_type, n_fil, n_overlapping, 
           true_spliced, found_spliced, found_spliced_fil, tx_mappability) %>% 
    group_by(mapper, tid, n_fil, n_overlapping, true_spliced, tx_mappability, filter_type) %>% 
    summarise( m_found_spliced=median(found_spliced, na.rm=T), 
               m_found_spliced_fil=median(found_spliced_fil)) %>% 
    ungroup() %>% 
    pivot_wider(names_from=mapper, 
                values_from=c(m_found_spliced, m_found_spliced_fil, n_fil), 
                id_cols=c('tid', 'n_overlapping', 'true_spliced', 'tx_mappability', 'filter_type')) %>% 
    mutate(diff_STAR=abs(true_spliced-m_found_spliced_STAR),
           diff_STAR_fil=abs(true_spliced-m_found_spliced_fil_STAR),
           diff_HISAT3N=abs(true_spliced-m_found_spliced_HISAT3N),
           diff_HISAT3N_fil=abs(true_spliced-m_found_spliced_fil_HISAT3N)
           ) %>%   
    mutate(best_HISAT3N=pmin(diff_HISAT3N, diff_HISAT3N_fil),
           best_STAR=pmin(diff_STAR, diff_STAR_fil )) %>% 
    mutate(best_diff=pmin(best_HISAT3N, best_STAR)) %>% 
    mutate(best_mapper_fmat=ifelse(best_HISAT3N<best_STAR, 'HISAT3N', ifelse(best_STAR<best_HISAT3N,'STAR','BOTH')),
           after_fil=(diff_STAR_fil==best_diff | diff_HISAT3N_fil==best_diff) & (diff_HISAT3N!=best_diff) & (diff_STAR!=best_diff),
           diff_to_other=abs(best_HISAT3N-best_STAR)
           ) %>% 
  left_join(m[['tx']], by='tid') %>% 
  left_join(m[['ga']] %>% select(tid, gene_type), by='tid')
  
# TODO: add best mapper for tx that cannot be intron-filtered (rnk1)
p1 = best_mapper_fmat %>% 
  group_by(tx_mappability, after_fil, filter_type) %>% 
  count(best_mapper_fmat) %>% 
  ggplot(aes(x=best_mapper_fmat, y=n, fill=after_fil)) +
  geom_bar(stat='identity') +
  facet_grid(filter_type~.) +
  ggtitle('All' )

p2 = best_mapper_fmat %>% 
  filter(best_diff<0.05, diff_to_other>0.05) %>% 
  group_by(tx_mappability, after_fil, filter_type) %>% 
  count(best_mapper_fmat) %>% 
  ggplot(aes(x=best_mapper_fmat, y=n, fill=after_fil)) +
  geom_bar(stat='identity') +
  facet_grid(filter_type~tx_mappability) +
  ggtitle('Substantial improvement, substantial better performance than other mapper',
          'best_diff<0.05, diff_to_other>0.05')

my_plot_grid(list(p1,p2), 'Best mapper per tx wrt. fmat')

```

### Write BED file of filtered introns per mapper
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of filtered introns per mapper
# ==============================================
tab = intron_mappability %>%
  left_join(m[['sj']], by = c('tid', 'fid'), all.x=T) %>% 
  arrange(chromosome, start)
for ( filter_type in c('include_converted', 'unconverted_only')) {
  for ( mapper in c('STAR', 'HISAT3N')) {
    tab %>% 
      filter(mapper==!!mapper, filter_type==!!filter_type) %>% 
      mutate(score=ifelse(is.na(don_win_map)|is.na(acc_win_map),0,(don_win_map+acc_win_map)/2*1000), 
             rgb=ifelse(filtered,'255,0,0','0,255,0'),
             start1=start,
             end1=end) %>% 
      select(chromosome,start,end,fid,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/filtered_introns_',filter_type,'.',mapper,'.bed'),
                paste0(mapper,"_filtered_introns_", filter_type))
  }
}
  
```

### Write BED file of best mapper per tx (wrt. fmat reconstruction)
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of tx per best mapper
# ==============================================
tab = best_mapper_fmat %>% 
  select(tid, filter_type, best_mapper_fmat, best_diff, diff_to_other, chromosome, start, end, strand) %>% 
  arrange(chromosome, start)


for ( filter_type in c('include_converted', 'unconverted_only')) {
  tab %>% 
    filter(filter_type==!!filter_type) %>% 
    mutate(score=ifelse(is.na(best_diff),0,(pmax(0,(1/3)-best_diff))*1000), 
           rgb=case_when(
             best_mapper_fmat=='STAR'~'255,0,0',
             best_mapper_fmat=='HISAT3N'~'0,255,0',
             T ~ '0,0,255'),
           start1=start,
           end1=end) %>% 
    select(chromosome,start,end,best_mapper_fmat,score,strand,start1,end1,rgb) %>% 
    write_bed( paste0(params$out_dir,'/best_mapper_fmat.',filter_type, '.bed'), 
               paste0('best_mapper_fmat_',filter_type))
}

```


# Examples

```{r, include=F, echo=F, eval=F}

tid='ENSMUST00000079496.8'

intron_mappability %>% 
  filter(tid==!!tid) %>% 
  left_join(m[['sj']], by=c('tid', 'fid')) %>% 
  ggplot(aes(factor(rnk), filtered)) + geom_point() + facet_grid(mapper~filter_type)

sfrac %>% 
  filter(tid==!!tid) %>% 
  select(tid, mapper, conversion_rate, filter_type, true_spliced, found_spliced, found_spliced_fil ) %>% 
  pivot_longer(-c(tid, mapper, conversion_rate, filter_type)) %>% 
  ggplot(aes(conversion_rate, value, col=name)) +
    geom_point() +
    facet_grid(mapper~filter_type)

```
