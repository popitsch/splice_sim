---
title: "splice_sim_sequencing_strategies.Rmd"
author: "tobias.neumann@imp.ac.at"
documentclass: article
fontsize: 10pt
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 14
    fig_height: 10
    fig_caption: true
    df_print: paged
  pdf_document:
    fig_width: 12
    fig_height: 10
    fig_caption: true
params:
    splice_sim_config:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/big4_slamseq_nf/splice_sim.config.json"
    genome_tx_noise_config:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/big4_slamseq_3endcounted_nf/splice_sim.config.json"
    transcriptome_3end_config:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/big4_slamseq_3end_transcriptomic_nf/splice_sim.config.json"
    genome_3end_config:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/big4_slamseq_3end_genomic_nf/splice_sim.config.json"
    out_dir:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/big4_slamseq_nf/analysis/"
---
<style type="text/css">
body, td {
   font-size: 10px;
}
code.r{
  font-size: 10px;
}
pre {
  font-size: 10px
}
div.blue pre { background-color:lightblue; }
div.blue pre.r { background-color:blue; }
</style>

<!--
rmarkdown::render('splice_sim_paper.Rmd', 'html_document')
-->

# INIT

```{r setup, include=FALSE}
require(data.table)
require(tidyr)
require(dplyr)
require(ggplot2)
require(scales)
require(rjson)
require(stringr)
require(VGAM)
require(cowplot)
require(arrow)
require(tictoc)
require(ggpubr)
require(minpack.lm)
require(readr)
require(testthat)
require(RColorBrewer)
require(skimr)
require(ggforce)
require(writexl)
require(xfun)
require(UpSetR)
require(ggalluvial)
# NB install arrow with snappy on Rstudio server
# Sys.setenv(ARROW_WITH_SNAPPY = "ON")
# Sys.setenv(NOT_CRAN="true")
# Sys.setenv(LIBARROW_BINARY="FALSE")
# install.packages("arrow", repos = "https://arrow-r-nightly.s3.amazonaws.com")

# to ensure stripping '\0' (nul) from character vector
options(arrow.skip_nul = TRUE)

# global theme
ggplot2::theme_set(theme_light())

# enable tidylog (has overhead!)
#require(tidylog)
# turn tidylog off
options("tidylog.display" = list()) 

# load data from TSV
load_table = function(dataF, append="", header=T, nrows=Inf) {
  dataF = as.character(paste0(dataF, append))
  print(paste("Loading", dataF))
  if ( endsWith(dataF, ".gz") ) {
    return(fread(cmd=paste('gunzip -c', dataF), header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  } else {
    return(fread(dataF, header=header, sep="\t", na.strings=c("na","NA",".", "None"), nrows=nrows))
  }
}

# multiple plots with single title
my_plot_grid = function(plots, main, ncol=NULL, nrow=NULL, labels=NULL) {
  
  if (!is.null(labels)){
    if (labels==T) { labels=LETTERS[1:length(plots)] }
  }
  plot_row=plot_grid(plotlist=plots, ncol=ncol, nrow=nrow, labels=labels)
  title <- ggdraw() + draw_label( main, fontface = 'bold', x = 0, hjust = 0 ) + theme(plot.margin = margin(0, 0, 0, 7))
  return (plot_grid(title, plot_row, ncol = 1, rel_heights = c(0.1, 1)))
}

# calculate confidence interval (ci),  a measure of precision 
# call with mtcars %>% calc_ci(mpg) or mtcars %>% group_by(cyl) %>% calc_ci(mpg)
# plot with ...  %>% ggplot(aes(x=cyl, y=col.mean)) + geom_line() + geom_ribbon(aes(ymin=col.lower, ymax=col.upper), alpha=0.1 ...)
calc_ci = function(d, col, min_lower_ci=NA, max_upper_ci=NA) {
  ret = d %>% summarise(
            col.mean := mean({{col}}, na.rm = TRUE),
            #col.median := median({{col}}, na.rm = TRUE),
            col.sd = sd({{col}}, na.rm = TRUE),
            col.n = n(),
            .groups = 'drop') %>%
  mutate(stderr = col.sd / sqrt(col.n),
         col.lower = col.mean - qt(1 - (0.05 / 2), col.n - 1) * stderr,
         col.upper = col.mean + qt(1 - (0.05 / 2), col.n - 1) * stderr) %>% 
  ungroup() %>% 
  mutate(col.lower = pmax(min_lower_ci, col.lower, na.rm=T),
         col.upper = pmin(max_upper_ci, col.upper, na.rm=T))
  return (ret)
}

# calculate interquartile range (iqr), a measure of dispersion
# call with mtcars %>% calc_iqr(mpg) or mtcars %>% group_by(cyl) %>% calc_iqr(mpg)
# plot with  ... %>% ggplot(aes(x=cyl, y=col.median)) + geom_line() + geom_ribbon(aes(ymin=col.lower, ymax=col.upper), alpha=0.1 ...)
calc_iqr = function(d, col) {
  d %>% summarise(
            col.median = median({{col}}, na.rm = T),
            #col.mean = mean({{col}}, na.rm = T),
            col.upper = quantile({{col}}, .75, na.rm = T),
            col.lower = quantile({{col}}, .25, na.rm = T),
            col.n = n(),
            .groups = 'drop')
}

#
# write result tibble to BED file
#
write_bed = function(dat, bed_file, title, header=F) {
  sink(bed_file)
  cat(paste0("track name=",title," description=\"",title,"\" useScore=1 itemRgb=\"On\"\n"))
  sink()
  dat %>% write_tsv( bed_file, col_names = F, append = T ) 
}

# calculates performance and coverage on grouped data.
# required columns: count, classification, len
calc_performance=function(tab, readlen) {
  tab %>% 
    summarise(count=sum(count)) %>% 
    pivot_wider(names_from=classification, values_from=count, names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(FP = ifelse("FP" %in% names(.), FP, 0)) %>%
    mutate(FP_raw = ifelse("FP_raw" %in% names(.), FP_raw, 0)) %>%
    mutate(FN = ifelse("FN" %in% names(.), FN, 0)) %>%
    mutate(
      read_count=TP+FN,
      cov=read_count*!!readlen/len,
      precision=ifelse(TP+FP>0, TP/(TP+FP), NA),
      recall=ifelse(TP+FN>0,TP/(TP+FN), NA),
      F1=ifelse((2*TP+FP+FN)>0,2*TP/(2*TP+FP+FN),NA)
  ) 
}

# calculate coverage for a grouped table
calc_coverage = function(grp_tab) {
  grp_tab %>% 
      summarise(count=sum(count)) %>% 
      pivot_wider(names_from=c(mapper,classification), values_from=count, names_sort=T) %>% 
      mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
      filter(len>conf$readlen) %>% # filter too-short introns as this will lead to wrong coverage calc. Example: ENSMUST00000116560.2_in5
      mutate(
        simulated=(HISAT3N_TP+HISAT3N_FN)*!!conf$readlen/len, # same as simulated_star!
        HISAT3N=(HISAT3N_TP+HISAT3N_FP)*!!conf$readlen/len,
        STAR=(STAR_TP+STAR_FP)*!!conf$readlen/len,
    ) %>% pivot_longer(c(simulated, HISAT3N, STAR), names_to='mapper') %>% 
    mutate(mapper=factor(mapper, levels=c('simulated', 'HISAT3N', 'STAR')),
           is_converted=ifelse(conversion_rate==0,'no conversions', 'converted reads')) %>% 
    ungroup()
}

# simple exponential decay model
decay_model= function(t, k) {
  return( exp(t * -k) )
}
# fit decay model and calculate halflife
fit_halflife = function(TP, dat) {
  if (any(is.na(dat))) {
    return (list(mod=NA,k=NA,hl=NA,pseudoR2=NA, bic=NA))
  }
  mod = tryCatch({
        nlsLM(dat~decay_model(TP, k),
              start=list(
                k=0),
              lower = c(0),                 
              upper = c(Inf),
              control = nls.lm.control(maxiter = 1000),
              na.action = na.omit)
      }, error=function(e){
        print(e)
      })
  if ( inherits(mod, "simpleError")) {return (list(mod=NA,k=NA,hl=NA,pseudoR2=NA, bic=NA)) }
  k=coef(mod)[length(coef(mod))]
  hl=log(2)/k
  rss = sum(residuals(mod)^2)
  tss = sum((dat - mean(dat ,na.rm = TRUE))^2 ,na.rm = TRUE)  # Total sum of squares
  pseudoR2 = 1 - (rss/tss)  # R-squared measure
  bic = BIC(mod)
  return (list(mod=mod,k=k,hl=hl,pseudoR2=pseudoR2, bic=bic))
}

# simple correlation plot
plot_corr = function(d, a, b, col_, main_title=NA, xlog=F, draw_diag=T, max_x=NA, show_legend=T) {
  thecor = paste("r_pearson = ", round(cor(d[[a]], d[[b]], use = "complete.obs"), 4), 
                 "\nr_spearman = ", round(cor(d[[a]], d[[b]], use = "complete.obs", method="spearman"), 4),
                 "\nn =",nrow(d)  )
  if (is.na(main_title)) {
    main_title=paste0("Correlation between ",a," and ",b)
  }
  p = ggplot( d, aes_string(x=a, y=b, col=col_) ) +
    geom_point(aes(alpha=0.2))  +
    ggtitle(main_title, thecor) 
  if ( !is.na(max_x) ) {
    p=p+xlim(0,max_x)+ylim(0, max_x)
  }
  if (draw_diag) {
    p=p+geom_abline(intercept = 0, slope = 1, col="black",linetype="dotted") 
  }
  if ( xlog ) {
    p=p+scale_x_log10()+scale_y_log10()
  }
  if ( ! show_legend ) {
    p=p+theme(legend.position="none")
  }
  return(p)
}

gn2tid = function(gn) {
  return(unique( m[['ga']] %>% filter(gene_name == gn) %>% pull(tid) ))
}
tid2coord = function(tid) {
  return(unique( m[['tx']] %>% filter(tid == !!tid) %>% select(chromosome, start, end) ))
}

# cache results
# usage: d = cache({x %>% head()}, 'x_head')
cache = function(my_expr, name, rerun=F) {
  xfun::cache_rds(my_expr, rerun=rerun, dir=paste0(params$out_dir, '/cache/'), file=name)
}

clean_cache = function() {
  cached_files = list.files(paste0(params$out_dir, '/cache/'), '_[0-9a-f]{32}[.]rds$', full.names = TRUE)
  unlink(cached_files)
}

```


# data

```{r data, include=F, echo=F, cache=T, eval=F}

home_dir=paste0(dirname(params$splice_sim_config),'/')
conf=fromJSON(paste(readLines(params$splice_sim_config), collapse=""))
# create result dir?
if (!dir.exists(params$out_dir)) {
  dir.create(params$out_dir)
} 
if (!dir.exists(paste0(params$out_dir,'/cache/'))) {
  dir.create(paste0(params$out_dir,'/cache/'))
} 

#home_dir='/Users/niko.popitsch/Desktop/data/projects/Ameres/splicing/splice_sim/testruns/big3_slamseq_nf/'

# results files (~45 G) 
data_file=paste0(home_dir,'/eva/results/data.rds')
data_file_mq20=paste0(home_dir,'/eva/results/data.mq20.rds')
meta_file=paste0(home_dir,'/eva/results/meta.rds')
  
if (file.exists(data_file)) {
  tic("load data")
  d=readRDS(data_file)
  d_mq20=readRDS(data_file_mq20)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(meta_file)) {
  tic("load metadata")
  m=readRDS(meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}


# to calc performance data
# d[['fx']] %>% 
#   group_by(fid,mapper,conversion_rate,classification,len,gene_name,num_exons,ftype) %>% 
#   calc_performance(conf$readlen) 

# to add meta data
# %>% 
#   left_join(m[['tx']], by=c('fid'='tid')) %>% # NB too-short tx are lost
#   left_join(m[['ga']], by=c('fid'='tid')) 


# shortcuts
tx = d[['tx']] %>% left_join(m[['tx']], by=c('fid'='tid')) 
tx20 = d_mq20[['tx']] %>% left_join(m[['tx']], by=c('fid'='tid')) 
fx = d[['fx']] %>% left_join(m[['fx']], by='fid') 
fx20 = d_mq20[['fx']] %>% left_join(m[['fx']], by='fid') 

# ===========================================================
# tx-noise 3' genome experiment
# ===========================================================
txnoise_genome_3end_conf=fromJSON(paste(readLines(params$genome_tx_noise_config), collapse=""))
txnoise_genome_3end_home_dir=paste0(dirname(params$genome_tx_noise_config),'/')

# results files (~45 G) 
txnoise_genome_3end_data_file=paste0(txnoise_genome_3end_home_dir,'/eva/results/data.rds')
txnoise_genome_3end_data_file_mq20=paste0(txnoise_genome_3end_home_dir,'/eva/results/data.mq20.rds')
txnoise_genome_3end_meta_file=paste0(txnoise_genome_3end_home_dir,'/eva/results/meta.rds')
  
if (file.exists(txnoise_genome_3end_data_file)) {
  tic("load data")
  d3ng=readRDS(txnoise_genome_3end_data_file)
  d3ng_mq20=readRDS(txnoise_genome_3end_data_file_mq20)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(txnoise_genome_3end_meta_file)) {
  tic("load metadata")
  m3ng=readRDS(txnoise_genome_3end_meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}

# shortcuts
tx3ng = d3ng[['tx']] %>% left_join(m3ng[['tx']], by=c('fid'='tid')) 
tx203ng = d3ng_mq20[['tx']] %>% left_join(m3ng[['tx']], by=c('fid'='tid')) 
fx3ng = d3ng[['fx']] %>% left_join(m3ng[['fx']], by='fid') 
fx203ng = d3ng_mq20[['fx']] %>% left_join(m3ng[['fx']], by='fid') 


# ===========================================================
# 3' transcriptome experiment
# ===========================================================
transcriptome_3end_conf=fromJSON(paste(readLines(params$transcriptome_3end_config), collapse=""))
transcriptome_3end_home_dir=paste0(dirname(params$transcriptome_3end_config),'/')

# results files (~45 G) 
transcriptome_3end_data_file=paste0(transcriptome_3end_home_dir,'/eva/results/data.rds')
transcriptome_3end_data_file_mq20=paste0(transcriptome_3end_home_dir,'/eva/results/data.mq20.rds')
transcriptome_3end_meta_file=paste0(transcriptome_3end_home_dir,'/eva/results/meta.rds')
  
if (file.exists(transcriptome_3end_data_file)) {
  tic("load data")
  d3t=readRDS(transcriptome_3end_data_file)
  d3t_mq20=readRDS(transcriptome_3end_data_file_mq20)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(transcriptome_3end_meta_file)) {
  tic("load metadata")
  m3t=readRDS(transcriptome_3end_meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}

# shortcuts
tx3t = d3t[['tx']] %>% left_join(m3t[['tx']], by=c('fid'='tid')) 
tx203t = d3t_mq20[['tx']] %>% left_join(m3t[['tx']], by=c('fid'='tid')) 
fx3t = d3t[['fx']] %>% left_join(m3t[['fx']], by='fid') 
fx203t = d3t_mq20[['fx']] %>% left_join(m3t[['fx']], by='fid') 

# ===========================================================
# 3' genome experiment
# ===========================================================
genome_3end_conf=fromJSON(paste(readLines(params$genome_3end_config), collapse=""))
genome_3end_home_dir=paste0(dirname(params$genome_3end_config),'/')

# results files (~45 G) 
genome_3end_data_file=paste0(genome_3end_home_dir,'/eva/results/data.rds')
genome_3end_data_file_mq20=paste0(genome_3end_home_dir,'/eva/results/data.mq20.rds')
genome_3end_meta_file=paste0(genome_3end_home_dir,'/eva/results/meta.rds')
  
if (file.exists(genome_3end_data_file)) {
  tic("load data")
  d3g=readRDS(genome_3end_data_file)
  d3g_mq20=readRDS(genome_3end_data_file_mq20)
  toc()
} else {
  stop("Could not find data_file")
}
if (file.exists(genome_3end_meta_file)) {
  tic("load metadata")
  m3g=readRDS(genome_3end_meta_file)
  toc()
} else {
  stop("Could not find meta_file")
}

# shortcuts
tx3g = d3g[['tx']] %>% left_join(m3g[['tx']], by=c('fid'='tid')) 
tx203g = d3g_mq20[['tx']] %>% left_join(m3g[['tx']], by=c('fid'='tid')) 
fx3g = d3g[['fx']] %>% left_join(m3g[['fx']], by='fid') 
fx203g = d3g_mq20[['fx']] %>% left_join(m3g[['fx']], by='fid') 

# result tables
results=list()

```


## QC

### NA counts

Calculate and plot the fraction of NA counts per table/column

```{r non_na, include=T, echo=F, cache=T}
# count non-NA values per column for all passed tables
count_na_per_column = function(tables) {
 counts=tibble()
 for (name in names(tables)) {
    print(name)
    tab=tables[[name]]
    nr=nrow(tab)
    if (!is.null(nr)) {
      if (nr>0) {
        counts=counts %>% rbind(
          tab %>% select(everything()) %>% summarise_all(funs(sum(is.na(.)))) %>% mutate(table=!!name) %>% collect() %>% pivot_longer(-table) %>% mutate(nr=!!nr, frac=value/nr)
        )
      }
    }
  }
  return (counts)
}

non_na_counts = count_na_per_column(c(setNames(d, paste0('d_',names(d))),setNames(m, paste0('m_',names(m)))) )
ggplot(non_na_counts, aes(x=name, y=frac)) +
  geom_bar(stat='identity') +
  facet_wrap(table~., scales = 'free') +
  ggtitle("Fraction of NA counts per table column") + 
  xlab("") + ylab("") +
  ylim(0,1) +
  coord_flip() 

non_na_counts = count_na_per_column(c(setNames(d3t, paste0('d_',names(d3t))),setNames(m3t, paste0('m_',names(m3t)))) )
ggplot(non_na_counts, aes(x=name, y=frac)) +
  geom_bar(stat='identity') +
  facet_wrap(table~., scales = 'free') +
  ggtitle("Fraction of NA counts per table column") + 
  xlab("") + ylab("") +
  ylim(0,1) +
  coord_flip() 

non_na_counts = count_na_per_column(c(setNames(d3g, paste0('d_',names(d3g))),setNames(m3g, paste0('m_',names(m3g)))) )
ggplot(non_na_counts, aes(x=name, y=frac)) +
  geom_bar(stat='identity') +
  facet_wrap(table~., scales = 'free') +
  ggtitle("Fraction of NA counts per table column") + 
  xlab("") + ylab("") +
  ylim(0,1) +
  coord_flip() 

ggsave(paste0(params$out_dir, 'qc_non_na_counts.pdf'), width=12, height=10)

```

### Missing tids

Some of the originally configured transcript ids are missing from result data. 
This is either because 
- there were no reads simulated as the annotation is smaller than read-size and there are no (longer) overlapping transcripts
- annotations are very long (e.g., Kcnip1 or Cmss1)

```{r missing_tids, include=T, echo=F, cache=T}
# how many tx did we recover
found_tids=unique(d[['tx']] %>% pull(fid))
found_tids_3t=unique(d3t[['tx']] %>% pull(fid))
found_tids_3g=unique(d3g[['tx']] %>% pull(fid))
all_tids = m[['all_tids']]

upset(fromList(list(all = all_tids, full_length = found_tids, transcriptome = found_tids_3t, genome = found_tids_3g, genome_noise = found_tids_3ng)),order.by="freq")

pdf(paste0(params$out_dir, 'qc_tids_ovlp.pdf'),onefile=FALSE)

upset(fromList(list(all = all_tids, full_length = found_tids, transcriptome = found_tids_3t, genome = found_tids_3g)),order.by="freq")

dev.off()

missedFullLength = setdiff(intersect(all_tids,intersect(found_tids_3t,found_tids_3g)),found_tids)
missed3End = setdiff(intersect(all_tids,found_tids),intersect(found_tids_3t,found_tids_3g))

# what are the missing tx from full-length?
missing_tx=load_table('/groups/ameres/Niko/projects/Ameres/splicing/data/slamstr/pooled.mm10.all/pooled.mm10.all.Slamstr.stats.trans.final.tsv.gz') %>% 
  select(tid=transcript_id, gene_type, len, ilen) %>% 
  filter(tid %in% m[['all_tids']]) %>% 
  mutate(cat=ifelse(!tid %in% missedFullLength, 'recovered','missing')) 
p1=missing_tx %>% ggplot(aes(x=factor(cat), y=len)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Length distribution of recovered vs missing tx",subtitle="Full-length sequencing") +
  geom_hline(yintercept = conf$readlen, col='red')
p2=missing_tx %>% ggplot(aes(x=factor(cat), y=ilen)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Intron Length distribution of recovered vs missing tx",subtitle="Full-length sequencing") +
  geom_hline(yintercept = conf$max_ilen, col='red')
# what are the missing tx from 3end?
missing_tx=load_table('/groups/ameres/Niko/projects/Ameres/splicing/data/slamstr/pooled.mm10.all/pooled.mm10.all.Slamstr.stats.trans.final.tsv.gz') %>% 
  select(tid=transcript_id, gene_type, len, ilen) %>% 
  filter(tid %in% m[['all_tids']]) %>% 
  mutate(cat=ifelse(!tid %in% missed3End, 'recovered','missing')) 
p3=missing_tx %>% ggplot(aes(x=factor(cat), y=len)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Length distribution of recovered vs missing tx",subtitle="3'end sequencing") +
  geom_hline(yintercept = conf$readlen, col='red')
p4=missing_tx %>% ggplot(aes(x=factor(cat), y=ilen)) + 
  geom_violin()  +scale_y_log10() + ggtitle("Intron Length distribution of recovered vs missing tx",subtitle="3'end sequencing") +
  geom_hline(yintercept = conf$max_ilen, col='red')

my_plot_grid(list(p1,p2,p3,p4), labels=T, 'QC only', nrow = 2)
ggsave(paste0(params$out_dir, 'qc_missing_tids.pdf'), width=12, height=10)

```

# Tx / Fx Mappability
## Coverage

- The target coverage is ~50X per isoform, i.e., 100X overall
- There is an edge effect as reads that overlap with 1bp are counted for their full length when coverage is calculated.
  This could explain the increased mean coverage for exons and introns. 
  For exons this effect is a bit reduced as the 1st/last exon also has an edge effect as we don't simulate reads that overlap the tx edges.

<div class = "blue">
<b>Coverage of simulated/mapped reads per isoform/genomic feature.</b>
A) Coverage distributions calculated from unconverted reads only (conversion rate = 0). 
   Both mappers have problems with spliced read mapping indicated by reduced coverage of spliced reads (panel mat/exon)
   and increased coverage of mature isoform reads that were false-positively mapped to introns (panel mat/intron). 
   Presumably, most of these reads are overlapping the splice junctions.
B) Mean coverage per conversion rate. 
   STAR shows decreased coverage of spliced reads with increasing conversion rates while HISAT3N is unaffected by this.
Note that deviations of the configured ~100X coverage for this 1:1 mix of premature/mature isoforms presumably stems from edge effects of the coverage
calculation that does not take partial read overlap into account. Coverage thresholds 0,50,100 are indicated by grey horizontal lines.
</div>


```{r coverage, include=T, echo=F, cache=T}

hlines=tribble(
  ~y,  ~cat,
  0,   1,
  50,  2,
  100, 3
)

cov_tx = cache({
  calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, len, classification ) ) 
}, 'cov_tx', rerun = F)

cov_tx2 = cache({
  calc_coverage(tx %>% group_by(mapper, conversion_rate, fid, true_isoform, len, classification ) ) 
}, 'cov_tx2', rerun = F)

cov_fx = cache({
 calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification ))
}, 'cov_fx', rerun = F)

cov_fx2 = cache({
  calc_coverage(fx %>% group_by(mapper, conversion_rate, fid, ftype, len, classification ))
}, 'cov_fx2', rerun = F)


pdf(paste0(params$out_dir, 'cov_full_length.pdf'), width=12, height=10)

p1 = cov_tx %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + 
  geom_boxplot() +
  scale_y_sqrt() +
  facet_grid(is_converted~., scales = 'free') +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage over tx interval') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p3 = cov_fx2 %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p4 = cov_tx2 %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per isoform') +
  facet_grid(is_converted~true_isoform, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

my_plot_grid(list(p1,p2,p3,p4), nrow=2, labels=T, 'QC: Coverage for converted and unconverted reads')

# final
p1 = cov_fx %>% 
  filter(is_converted=='no conversions') %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx %>% group_by(conversion_rate, ftype, true_isoform, mapper) %>% calc_ci(value) %>% 
  ggplot(aes(x=conversion_rate, y=col.mean, col=mapper, group=mapper)) + 
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean coverage per condition') +
  facet_grid(.~true_isoform+ftype)

my_plot_grid(list(p1,p2), labels=T, 'Coverage per mapper', nrow = 1)


# calc_coverage(d[['tx']] %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% group_by(conversion_rate,mapper) %>% summarise(m=mean(value)) %>% ggplot(aes(conversion_rate,m,fill=mapper)) + geom_bar(stat='identity', position = 'dodge') + ggtitle('Mean tx coverage per mapper and condition')

# NOTE: why is intron/pre coverage so high?
# I think this is because of an edge effect at intron/exon boundaries. Reads that overlap only 1 bp with intron are counted for their full rl. 
# The longer the intron, the less this influence gets:
# tab %>% filter(conversion_rate==0, mapper=='simulated') %>% ggplot(aes(len, value)) + geom_point() + facet_wrap(ftype~true_isoform, scales='free') + geom_vline(xintercept = 100, col='red')
# for exons, this effect is reduced by the edge effect on the 1st and last exon:
#tab %>% filter(conversion_rate==0, mapper=='simulated', ftype=='exon') %>% left_join(m[['fx']]) %>% mutate(is_edge=(rnk==1 | rnk==tx_rnk)) %>% 
#  ggplot(aes(x=is_edge, y=value)) + geom_boxplot() + facet_wrap(ftype~true_isoform, scales='free') 


#remove()

dev.off()

```

```{r coverage2, include=T, echo=F, cache=T}

hlines=tribble(
  ~y,  ~cat,
  0,   1,
  50,  2,
  100, 3
)

cov_tx_3t = cache({
  calc_coverage(tx3t %>% group_by(mapper, conversion_rate, fid, len, classification ) ) 
}, 'cov_tx_3t', rerun = F)

cov_tx2_3t = cache({
  calc_coverage(tx3t %>% group_by(mapper, conversion_rate, fid, true_isoform, len, classification ) ) 
}, 'cov_tx2_3t', rerun = F)

cov_fx_3t = cache({
 calc_coverage(fx3t %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification ))
}, 'cov_fx_3t', rerun = F)

cov_fx2_3t = cache({
  calc_coverage(fx3t %>% group_by(mapper, conversion_rate, fid, ftype, len, classification ))
}, 'cov_fx2_3t', rerun = F)


pdf(paste0(params$out_dir, 'cov_3end_transcriptome.pdf'), width=12, height=10)

p1 = cov_tx_3t %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + 
  geom_boxplot() +
  scale_y_sqrt() +
  facet_grid(is_converted~., scales = 'free') +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage over tx interval') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx_3t %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p3 = cov_fx2_3t %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p4 = cov_tx2_3t %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per isoform') +
  facet_grid(is_converted~true_isoform, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

my_plot_grid(list(p1,p2,p3,p4), nrow=2, labels=T, 'QC: Coverage for converted and unconverted reads')

# final
p1 = cov_fx_3t %>% 
  filter(is_converted=='no conversions') %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx_3t %>% group_by(conversion_rate, ftype, true_isoform, mapper) %>% calc_ci(value) %>% 
  ggplot(aes(x=conversion_rate, y=col.mean, col=mapper, group=mapper)) + 
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean coverage per condition') +
  facet_grid(.~true_isoform+ftype)

my_plot_grid(list(p1,p2), labels=T, 'Coverage per mapper', nrow = 1)


# calc_coverage(d[['tx']] %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% group_by(conversion_rate,mapper) %>% summarise(m=mean(value)) %>% ggplot(aes(conversion_rate,m,fill=mapper)) + geom_bar(stat='identity', position = 'dodge') + ggtitle('Mean tx coverage per mapper and condition')

# NOTE: why is intron/pre coverage so high?
# I think this is because of an edge effect at intron/exon boundaries. Reads that overlap only 1 bp with intron are counted for their full rl. 
# The longer the intron, the less this influence gets:
# tab %>% filter(conversion_rate==0, mapper=='simulated') %>% ggplot(aes(len, value)) + geom_point() + facet_wrap(ftype~true_isoform, scales='free') + geom_vline(xintercept = 100, col='red')
# for exons, this effect is reduced by the edge effect on the 1st and last exon:
#tab %>% filter(conversion_rate==0, mapper=='simulated', ftype=='exon') %>% left_join(m[['fx']]) %>% mutate(is_edge=(rnk==1 | rnk==tx_rnk)) %>% 
#  ggplot(aes(x=is_edge, y=value)) + geom_boxplot() + facet_wrap(ftype~true_isoform, scales='free') 


#remove()

dev.off()

```

```{r coverage3, include=T, echo=F, cache=T}

hlines=tribble(
  ~y,  ~cat,
  0,   1,
  50,  2,
  100, 3
)

cov_tx_3g = cache({
  calc_coverage(tx3g %>% group_by(mapper, conversion_rate, fid, len, classification ) ) 
}, 'cov_tx_3g', rerun = F)

cov_tx2_3g = cache({
  calc_coverage(tx3g %>% group_by(mapper, conversion_rate, fid, true_isoform, len, classification ) ) 
}, 'cov_tx2_3g', rerun = F)

cov_fx_3g = cache({
 calc_coverage(fx3g %>% group_by(mapper, conversion_rate, fid, true_isoform, ftype, len, classification ))
}, 'cov_fx_3g', rerun = F)

cov_fx2_3g = cache({
  calc_coverage(fx3g %>% group_by(mapper, conversion_rate, fid, ftype, len, classification ))
}, 'cov_fx2_3g', rerun = F)


pdf(paste0(params$out_dir, 'cov_3end_genome.pdf'), width=12, height=10)

p1 = cov_tx_3g %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + 
  geom_boxplot() +
  scale_y_sqrt() +
  facet_grid(is_converted~., scales = 'free') +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage over tx interval') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx_3g %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p3 = cov_fx2_3g %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p4 = cov_tx2_3g %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per isoform') +
  facet_grid(is_converted~true_isoform, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

my_plot_grid(list(p1,p2,p3,p4), nrow=2, labels=T, 'QC: Coverage for converted and unconverted reads')

# final
p1 = cov_fx_3g %>% 
  filter(is_converted=='no conversions') %>% 
  ggplot(aes(x=mapper, y=value, fill=mapper)) + geom_boxplot() +
  scale_y_sqrt() +
  geom_hline(data = hlines, aes(yintercept = y, linetype=factor(cat)), color = 'grey', show.legend=FALSE ) +
  ggtitle('Coverage per genomic feature') +
  facet_grid(is_converted~true_isoform+ftype, scales = 'free') + theme(legend.position="none") + xlab('') + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

p2 = cov_fx_3g %>% group_by(conversion_rate, ftype, true_isoform, mapper) %>% calc_ci(value) %>% 
  ggplot(aes(x=conversion_rate, y=col.mean, col=mapper, group=mapper)) + 
  geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean coverage per condition') +
  facet_grid(.~true_isoform+ftype)

my_plot_grid(list(p1,p2), labels=T, 'Coverage per mapper', nrow = 1)


# calc_coverage(d[['tx']] %>% group_by(mapper, conversion_rate, fid, len, classification ) ) %>% group_by(conversion_rate,mapper) %>% summarise(m=mean(value)) %>% ggplot(aes(conversion_rate,m,fill=mapper)) + geom_bar(stat='identity', position = 'dodge') + ggtitle('Mean tx coverage per mapper and condition')

# NOTE: why is intron/pre coverage so high?
# I think this is because of an edge effect at intron/exon boundaries. Reads that overlap only 1 bp with intron are counted for their full rl. 
# The longer the intron, the less this influence gets:
# tab %>% filter(conversion_rate==0, mapper=='simulated') %>% ggplot(aes(len, value)) + geom_point() + facet_wrap(ftype~true_isoform, scales='free') + geom_vline(xintercept = 100, col='red')
# for exons, this effect is reduced by the edge effect on the 1st and last exon:
#tab %>% filter(conversion_rate==0, mapper=='simulated', ftype=='exon') %>% left_join(m[['fx']]) %>% mutate(is_edge=(rnk==1 | rnk==tx_rnk)) %>% 
#  ggplot(aes(x=is_edge, y=value)) + geom_boxplot() + facet_wrap(ftype~true_isoform, scales='free') 


#remove()

dev.off()

```


## Mappability comparison

<div class = "blue">
<b>Mappabilities in the respective genomic intervals.</b>
Mappability in either the entire transcript, the 3' end genomic window or the 3' end genomic window in a transcriptome mapping setting
</div>


```{r map_comp, include=T, echo=F, cache=T}

txmapcmp = m[["tx"]] %>%
  dplyr::select(tid, mean_map, mappability) %>%
  dplyr::rename(gn = mean_map) %>%
  dplyr::left_join(m3t[["tx"]] %>%
                    dplyr::select(tid, mean_map) %>%
                    dplyr::rename(`3end_tx` = mean_map),
  by = "tid") %>%
  dplyr::left_join(m3g[["tx"]] %>%
                    dplyr::select(tid, mean_map) %>%
                    dplyr::rename(`3end_gn` = mean_map),
  by = "tid")

pdf(paste0(params$out_dir, 'mappability_interval_strategies.pdf'), width=8, height=6)

txmapcmp %>%
  dplyr::select(mappability, tid, everything()) %>%
  tidyr::gather(type, value, 3:5) %>%
  dplyr::mutate(type = factor(type, levels = c("gn","3end_gn","3end_tx"))) %>%
  ggplot(aes(x=type, y = value)) +
  geom_boxplot() +
  facet_grid(~mappability) +
  ylab("Mappability") + xlab("") +
  ggtitle('Mappabilities across sequencing strategies')

txmapcmp %>%
  dplyr::select(mappability, tid, everything()) %>%
  tidyr::gather(type, value, 3:5) %>%
  dplyr::mutate(type = factor(type, levels = c("gn","3end_gn","3end_tx"))) %>%
  ggplot(aes(x=type, y = value)) +
  geom_boxplot() +
  ylab("Mappability") + xlab("") +
  ggtitle('Mappabilities across sequencing strategies')

mappabilityCmp = rbind(
  m[["tx"]] %>% dplyr::select(tid, mappability) %>% dplyr::mutate(type = "gn"),
  m3t[["tx"]] %>% dplyr::select(tid, mappability) %>% dplyr::mutate(type = "3end_tx"),
  m3g[["tx"]] %>% dplyr::select(tid, mappability) %>% dplyr::mutate(type = "3end_gn")
)

upset(fromList(list(gn = mappabilityCmp %>% dplyr::filter(type == "gn", mappability == "high") %>% .$tid,
                    `3end_tx` = mappabilityCmp %>% dplyr::filter(type == "3end_tx", mappability == "high") %>% .$tid,
                    `3end_gn` = mappabilityCmp %>% dplyr::filter(type == "3end_gn", mappability == "high") %>% .$tid)), order.by="freq")

upset(fromList(list(gn = mappabilityCmp %>% dplyr::filter(type == "gn", mappability == "medium") %>% .$tid,
                    `3end_tx` = mappabilityCmp %>% dplyr::filter(type == "3end_tx", mappability == "medium") %>% .$tid,
                    `3end_gn` = mappabilityCmp %>% dplyr::filter(type == "3end_gn", mappability == "medium") %>% .$tid)), order.by="freq")

upset(fromList(list(gn = mappabilityCmp %>% dplyr::filter(type == "gn", mappability == "low") %>% .$tid,
                    `3end_tx` = mappabilityCmp %>% dplyr::filter(type == "3end_tx", mappability == "low") %>% .$tid,
                    `3end_gn` = mappabilityCmp %>% dplyr::filter(type == "3end_gn", mappability == "low") %>% .$tid)), order.by="freq")

mappabilityCmp %>%
  dplyr::mutate(type = factor(type, levels = c("gn","3end_gn","3end_tx"))) %>%
  ggplot(aes(x = type)) +
  geom_bar() +
  facet_wrap(~mappability) +
  xlab("") + ylab("# transcripts") +
  ggtitle('Transcripts per mappability class across sequencing strategies')

mappabilityClassAlluvia = m[["tx"]] %>%
  dplyr::select(tid, mappability) %>%
  dplyr::rename(gn = mappability) %>%
  dplyr::full_join(
    m3g[["tx"]] %>%
      dplyr::select(tid, mappability) %>%
      dplyr::rename(`3end_gn` = mappability)
  ) %>%
  dplyr::full_join(
    m3t[["tx"]] %>%
      dplyr::select(tid, mappability) %>%
      dplyr::rename(`3end_tx` = mappability)
  )

mappabilityClassAlluvia %>%
  dplyr::group_by(gn, `3end_gn`, `3end_tx`) %>%
  dplyr::summarise(freq = n()) %>%
  ggplot(aes(y = freq, axis1 = `3end_gn`, axis2 = gn, axis3 = `3end_tx`)) +
  geom_alluvium(aes(fill = gn), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("3end_gn", "gn", "3end_tx"), expand = c(.05, .05)) +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  ylab("# transcripts") +
  ggtitle('Transcripts redistribution per mappability class across sequencing strategies')

dev.off()

```


## Convertability comparison

<div class = "blue">
<b>Convertabilities in the respective genomic intervals.</b>
Convertability in either the entire transcript, the 3' end genomic window or the 3' end genomic window in a transcriptome mapping setting
</div>


```{r conv_comp, include=T, echo=F, cache=T}

txmapcmp = m[["tx"]] %>%
  dplyr::select(tid, frac_convertible, convertibility) %>%
  dplyr::rename(gn = frac_convertible) %>%
  dplyr::left_join(m3t[["tx"]] %>%
                    dplyr::select(tid, frac_convertible) %>%
                    dplyr::rename(`3end_tx` = frac_convertible),
  by = "tid") %>%
  dplyr::left_join(m3g[["tx"]] %>%
                    dplyr::select(tid, frac_convertible) %>%
                    dplyr::rename(`3end_gn` = frac_convertible),
  by = "tid")

pdf(paste0(params$out_dir, 'convertability_interval_strategies.pdf'), width=8, height=6)

txmapcmp %>%
  dplyr::select(convertibility, tid, everything()) %>%
  tidyr::gather(type, value, 3:5) %>%
  dplyr::mutate(type = factor(type, levels = c("gn","3end_gn","3end_tx"))) %>%
  ggplot(aes(x=type, y = value)) +
  geom_boxplot() +
  facet_grid(~convertibility) +
  ylab("Convertability") + xlab("") +
  ggtitle('Convertability across sequencing strategies')

txmapcmp %>%
  dplyr::select(convertibility, tid, everything()) %>%
  tidyr::gather(type, value, 3:5) %>%
  dplyr::mutate(type = factor(type, levels = c("gn","3end_gn","3end_tx"))) %>%
  ggplot(aes(x=type, y = value)) +
  geom_boxplot() +
  ylab("Convertability") + xlab("") +
  ggtitle('Convertability across sequencing strategies')

convertibilityCmp = rbind(
  m[["tx"]] %>% dplyr::select(tid, convertibility) %>% dplyr::mutate(type = "gn"),
  m3t[["tx"]] %>% dplyr::select(tid, convertibility) %>% dplyr::mutate(type = "3end_tx"),
  m3g[["tx"]] %>% dplyr::select(tid, convertibility) %>% dplyr::mutate(type = "3end_gn")
)

upset(fromList(list(gn = convertibilityCmp %>% dplyr::filter(type == "gn", convertibility == "high") %>% .$tid,
                    `3end_tx` = convertibilityCmp %>% dplyr::filter(type == "3end_tx", convertibility == "high") %>% .$tid,
                    `3end_gn` = convertibilityCmp %>% dplyr::filter(type == "3end_gn", convertibility == "high") %>% .$tid)), order.by="freq")

upset(fromList(list(gn = convertibilityCmp %>% dplyr::filter(type == "gn", convertibility == "medium") %>% .$tid,
                    `3end_tx` = convertibilityCmp %>% dplyr::filter(type == "3end_tx", convertibility == "medium") %>% .$tid,
                    `3end_gn` = convertibilityCmp %>% dplyr::filter(type == "3end_gn", convertibility == "medium") %>% .$tid)), order.by="freq")

upset(fromList(list(gn = convertibilityCmp %>% dplyr::filter(type == "gn", convertibility == "low") %>% .$tid,
                    `3end_tx` = convertibilityCmp %>% dplyr::filter(type == "3end_tx", convertibility == "low") %>% .$tid,
                    `3end_gn` = convertibilityCmp %>% dplyr::filter(type == "3end_gn", convertibility == "low") %>% .$tid)), order.by="freq")

convertibilityCmp %>%
  dplyr::mutate(type = factor(type, levels = c("gn","3end_gn","3end_tx"))) %>%
  ggplot(aes(x = type)) +
  geom_bar() +
  facet_wrap(~convertibility) +
  xlab("") + ylab("# transcripts") +
  ggtitle('Transcripts per convertibility class across sequencing strategies')

convertibilityClassAlluvia = m[["tx"]] %>%
  dplyr::select(tid, convertibility) %>%
  dplyr::rename(gn = convertibility) %>%
  dplyr::full_join(
    m3g[["tx"]] %>%
      dplyr::select(tid, convertibility) %>%
      dplyr::rename(`3end_gn` = convertibility)
  ) %>%
  dplyr::full_join(
    m3t[["tx"]] %>%
      dplyr::select(tid, convertibility) %>%
      dplyr::rename(`3end_tx` = convertibility)
  )

convertibilityClassAlluvia %>%
  dplyr::group_by(gn, `3end_gn`, `3end_tx`) %>%
  dplyr::summarise(freq = n()) %>%
  ggplot(aes(y = freq, axis1 = `3end_gn`, axis2 = gn, axis3 = `3end_tx`)) +
  geom_alluvium(aes(fill = gn), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("3end_gn", "gn", "3end_tx"), expand = c(.05, .05)) +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  ylab("# transcripts") +
  ggtitle('Transcripts redistribution per convertibility class across sequencing strategies')

dev.off()

```

## MAP Performance

<div class = "blue">
<b>Mapping performance per conversion rate.</b>
Precision, recall and F1 score per feature type (tx: transcript), stratified by originating isoform (pre: premature, unspliced isoform; mat: mature, fully spliced isoform) and standard genomic mappability. 
Performance drops with increasing conversion rate for STAR but not HISAT3N.
</div>

```{r map_perf, include=T, echo=F, cache=T}

perf_tx = cache({
  tx %>% 
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_tx', rerun = F)

perf_fx = cache({
  fx %>% 
    select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_fx', rerun = F)

perf_fx3g = cache({
  fx3g %>% 
    select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_fx3g', rerun = F)

perf_tx3g = cache({
  tx3g %>% 
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_tx3g', rerun = F)

perf_fx3t = cache({
  fx3t %>% 
    select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_fx3t', rerun = F)

perf_tx3t = cache({
  tx3t %>% 
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_tx3t', rerun = F)

perf_fx3g = cache({
  fx3g %>% 
    select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_fx3g', rerun = F)

perf_tx3ng = cache({
  tx3ng %>% 
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_tx3ng', rerun = F)

perf_fx3ng = cache({
  fx3ng %>% 
    select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
    group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
             num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup()
}, 'perf_fx3ng', rerun = F)

perf = bind_rows(perf_tx, perf_fx) 

perf3g = bind_rows(perf_tx3g, perf_fx3g)

perf3t = bind_rows(perf_tx3t, perf_fx3t)

perf3ng = bind_rows(perf_tx3ng, perf_fx3ng)

# Low genome mappability, high 3' end genome mappability

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "low" & `3end_gn` == "high") %>% .$tid

mapSummaryPlot = tibble(class = "low_gn_high_3end_gn", tx = length(unique(toi)))

perf_low_genome_gn = cache({
  rbind(
    tx %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "gn")
}, 'perf_low_genome_gn', rerun = F)

perf_low_genome_3end_gn = cache({
  rbind(
    tx3g %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3g %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_gn")
}, 'perf_low_genome_3end_gn', rerun = F)

perf_low_genome_3end_tx = cache({
  rbind(
    tx3t %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3t %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_tx")
}, 'perf_low_genome_3end_tx', rerun = F)

# High genome mappability, low 3' end genome mappability

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_gn` == "low") %>% .$tid

mapSummaryPlot = rbind(mapSummaryPlot,
  tibble(class = "high_gn_low_3end_gn", tx = length(unique(toi)))
)

perf_low_3end_genome_gn = cache({
  rbind(
    tx %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "gn")
}, 'perf_low_3end_genome_gn', rerun = F)

perf_low_3end_genome_3end_gn = cache({
  rbind(
    tx3g %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3g %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_gn")
}, 'perf_low_3end_genome_3end_gn', rerun = F)

perf_low_3end_genome_3end_tx = cache({
  rbind(
    tx3t %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3t %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_tx")
}, 'perf_low_3end_genome_3end_tx', rerun = F)

# High genome mappability, low 3' end transcriptome mappability

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_tx` == "low") %>% .$tid

mapSummaryPlot = rbind(mapSummaryPlot,
  tibble(class = "high_gn_low_3end_tx", tx = length(unique(toi)))
)

perf_low_3end_transcriptome_gn = cache({
  rbind(
    tx %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "gn")
}, 'perf_low_3end_transcriptome_gn', rerun = F)

perf_low_3end_transcriptome_3end_gn = cache({
  rbind(
    tx3g %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3g %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_gn")
}, 'perf_low_3end_transcriptome_3end_gn', rerun = F)

perf_low_3end_transcriptome_3end_tx = cache({
  rbind(
    tx3t %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3t %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_tx")
}, 'perf_low_3end_transcriptome_3end_tx', rerun = F)

# Low genome convertibility, high 3' end genome convertibility

toi = convertibilityClassAlluvia %>% dplyr::filter(gn == "low" & `3end_gn` == "high") %>% .$tid

convertabilitySummaryPlot = tibble(class = "low_gn_high_3end_gn", tx = length(unique(toi)))

perf_conv_low_genome_gn = cache({
  rbind(
    tx %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "gn")
}, 'perf_conv_low_genome_gn', rerun = F)

perf_conv_low_genome_3end_gn = cache({
  rbind(
    tx3g %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3g %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_gn")
}, 'perf_conv_low_genome_3end_gn', rerun = F)

perf_conv_low_genome_3end_tx = cache({
  rbind(
    tx3t %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3t %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_tx")
}, 'perf_conv_low_genome_3end_tx', rerun = F)

# High genome convertibility, low 3' end genome convertibility

toi = convertibilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_gn` == "low") %>% .$tid

convertabilitySummaryPlot = rbind(convertabilitySummaryPlot,
  tibble(class = "high_gn_low_3end_gn", tx = length(unique(toi)))
)

perf_conv_high_genome_gn = cache({
  rbind(
    tx %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "gn")
}, 'perf_conv_high_genome_gn', rerun = F)

perf_conv_high_genome_3end_gn = cache({
  rbind(
    tx3g %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3g %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_gn")
}, 'perf_conv_high_genome_3end_gn', rerun = F)

perf_conv_high_genome_3end_tx = cache({
  rbind(
    tx3t %>%
      dplyr::filter(fid %in% toi) %>%
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup(),
    fx3t %>% 
      dplyr::filter(tid %in% toi) %>%
      select(-rnk) %>% rename(rnk=tx_rnk) %>% #mappability=tx_mappability; we could also use tx_mappability here?
      group_by(mapper, conversion_rate, classification, len, true_isoform, mappability, mean_map, GC, 
               num_exons, rnk, frac_convertible, convertibility, ftype) %>% 
      calc_performance(conf$readlen) %>% 
      mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
      filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
      ungroup()
  ) %>% dplyr::mutate(tech = "3end_tx")
}, 'perf_conv_high_genome_3end_tx', rerun = F)

pdf(paste0(params$out_dir, 'map_perf.pdf'), width=8, height=6)

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(precision) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median precision per condition tx') 

perf3g %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(precision) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median precision per condition 3end genome') 

perf3ng %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(precision) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median precision per condition 3end transcript-noise genome') 

perf3t %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(precision) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median precision per condition 3end transcriptome') 

perf %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(recall) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median recall per condition tx')

perf3g %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(recall) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median recall per condition 3end genome')

perf3t %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(recall) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype) +
  ylab("") +
  ggtitle('Median recall per condition 3end transcriptome') 

techperf = rbind(
  perf %>% dplyr::mutate(tech = "gn"),
  perf3g %>% dplyr::mutate(tech = "3end_gn"),
  perf3t %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

techperf %>% group_by(tech, conversion_rate, mapper, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(tech~ftype, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "sequencing strategy", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per condition tx per sequencing strategy')

mapSummaryPlot %>%
  ggplot(aes(x = class, y = tx)) +
  geom_bar(stat="identity") +
  xlab("") + ylab("# tx") +
  ggtitle('Number of extreme tx mappability swaps')

techperf = rbind(
  perf_low_genome_gn,
  perf_low_genome_3end_gn,
  perf_low_genome_3end_tx
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

techperf %>% group_by(tech, conversion_rate, mapper, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(tech~ftype, scales = 'fixed') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "sequencing strategy", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Low mappable genomic vs high mappable 3end genes')

techperf = rbind(
  perf_low_3end_genome_gn,
  perf_low_3end_genome_3end_gn,
  perf_low_3end_genome_3end_tx
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

techperf %>% group_by(tech, conversion_rate, mapper, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(tech~ftype, scales = 'fixed') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "sequencing strategy", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('High mappable genomic vs low mappable 3end genes')

techperf = rbind(
  perf_low_3end_transcriptome_gn,
  perf_low_3end_transcriptome_3end_gn,
  perf_low_3end_transcriptome_3end_tx
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

techperf %>% group_by(tech, conversion_rate, mapper, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(tech~ftype, scales = 'fixed') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "sequencing strategy", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('High mappable genomic vs low mappable 3end transcriptome genes')

convertabilitySummaryPlot %>%
  ggplot(aes(x = class, y = tx)) +
  geom_bar(stat="identity") +
  xlab("") + ylab("# tx") +
  ggtitle('Number of extreme tx convertibility swaps')

techperf = rbind(
  perf_conv_low_genome_gn,
  perf_conv_low_genome_3end_gn,
  perf_conv_low_genome_3end_tx
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

techperf %>% group_by(tech, conversion_rate, mapper, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(tech~ftype, scales = 'fixed') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "sequencing strategy", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Low convertible genomic vs high convertible 3end genes')

techperf = rbind(
  perf_conv_high_genome_gn,
  perf_conv_high_genome_3end_gn,
  perf_conv_high_genome_3end_tx
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

techperf %>% group_by(tech, conversion_rate, mapper, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(tech~ftype, scales = 'fixed') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "sequencing strategy", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('High convertible genomic vs low convertible 3end genes')

perf3g %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per condition 3end genome')

perf3t %>% group_by(conversion_rate, mapper, mappability, true_isoform, ftype) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per condition 3end transcriptome') 

perf_tx %>% filter(mappability=='high') %>% 
  group_by(conversion_rate, mapper, true_isoform, num_exons) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_wrap(num_exons~.) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per tx', 'by number of exons (high mappability only)') 

perf_tx3g %>% filter(mappability=='high') %>% 
  group_by(conversion_rate, mapper, true_isoform, num_exons) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_wrap(num_exons~.) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per 3end genome', 'by number of exons (high mappability only)') 

perf_tx3t %>% filter(mappability=='high') %>% 
  group_by(conversion_rate, mapper, true_isoform, num_exons) %>% calc_iqr(F1) %>% 
  ggplot(aes(conversion_rate, col.median, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_wrap(num_exons~.) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Median F1 per 3end transcriptome', 'by number of exons (high mappability only)') 

dev.off()
```

### MAP result tables

TODO: add mq20 F1 values?

```{r map_results, include=F, echo=F, cache=T}
calc_map_table = function(tab) {
  tab = tab %>% 
  select(fid, ftype, mapper, conversion_rate, classification, count) %>% 
  group_by(fid, ftype, mapper, conversion_rate, classification) %>% 
  summarise(count=sum(count), .groups='drop') %>%
  pivot_wider(names_from=classification, values_from=count) %>%
  mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
  mutate(F1=ifelse(((2*TP+FP+FN)>0) & (TP+FN>0),2*TP/(2*TP+FP+FN),NA))
  
  # calc F1 from conversion_rate==0 only
  noconv=tab %>% filter(conversion_rate==0) %>% select(fid, mapper, ftype, F1_0=F1)
  # create final table
  tab = tab %>% group_by(fid,ftype,mapper) %>% 
    summarise(TP=sum(TP), FP=sum(FP), FN=sum(FN), .groups='drop') %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(F1=ifelse(((2*TP+FP+FN)>0) & (TP+FN>0),2*TP/(2*TP+FP+FN),NA)) %>% # set F1 to NA if no reads were simulated for tx (e.g., because too short)
    left_join(noconv, by=c('fid', 'mapper', 'ftype')) %>% # add F1_0
    pivot_wider(names_from=mapper, values_from=c(F1_0, F1), id_cols=c('fid', 'ftype'))
  
  return(tab)
}


# result tables
results[['map_tx_tab']] = tx %>% calc_map_table() %>% rename(tid='fid') %>% 
  mutate(best_mapper_no_conv = ifelse(F1_0_HISAT3N-F1_0_STAR>0.05, 'HISAT3N',
                               ifelse(F1_0_HISAT3N-F1_0_STAR< -0.05,'STAR','BOTH')),
         best_mapper_conv = ifelse(F1_HISAT3N-F1_STAR>0.05, 'HISAT3N',
                            ifelse(F1_HISAT3N-F1_STAR< -0.05,'STAR','BOTH'))) %>% 
  left_join(m[['tx']], by=c('tid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['map_ex_tab']] = fx %>% filter(ftype=='exon') %>% calc_map_table() %>% 
  mutate(best_mapper_no_conv = ifelse(F1_0_HISAT3N-F1_0_STAR>0.05, 'HISAT3N',
                               ifelse(F1_0_HISAT3N-F1_0_STAR< -0.05,'STAR','BOTH')),
         best_mapper_conv = ifelse(F1_HISAT3N-F1_STAR>0.05, 'HISAT3N',
                            ifelse(F1_HISAT3N-F1_STAR< -0.05,'STAR','BOTH'))) %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['map_in_tab']] = fx %>% filter(ftype=='intron') %>% calc_map_table() %>% 
  mutate(best_mapper_no_conv = ifelse(F1_0_HISAT3N-F1_0_STAR>0.05, 'HISAT3N',
                               ifelse(F1_0_HISAT3N-F1_0_STAR< -0.05,'STAR','BOTH')),
         best_mapper_conv = ifelse(F1_HISAT3N-F1_STAR>0.05, 'HISAT3N',
                            ifelse(F1_HISAT3N-F1_STAR< -0.05,'STAR','BOTH'))) %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

```


### MAP Write BED file of best mapper 
```{r, include=F, echo=F, eval=F}
# ==============================================
# write BED file of best mapper
# ==============================================
results[['map_tx_tab']] %>%
  mutate(score=round(pmax(F1_HISAT3N, F1_STAR)*1000),
         best_mapper=best_mapper_conv,
         rgb=ifelse(best_mapper=='HISAT3N','255,0,0','0,255,0'),
         start1=start,
         end1=end
         ) %>% 
  arrange(chromosome, start) %>% 
      select(chromosome,start,end,best_mapper,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/best_mapper_map.include_converted.bed'),
                paste0("best_mapper_map.include_converted"))

results[['map_tx_tab']] %>%
  mutate(score=round(pmax(F1_0_HISAT3N, F1_0_STAR)*1000),
         best_mapper=best_mapper_no_conv,
         rgb=ifelse(best_mapper=='HISAT3N','255,0,0','0,255,0'),
         start1=start,
         end1=end
         ) %>% 
  arrange(chromosome, start) %>% 
      select(chromosome,start,end,best_mapper,score,strand,start1,end1,rgb) %>%
      write_bed(paste0(params$out_dir,'/best_mapper_map.unconverted_only.bed'),
                paste0("best_mapper_map.unconverted_only"))
```

## FCR

```{r fcr, include=T, echo=F, cache=T}

fcr = cache({
  tx %>% 
    bind_rows(fx) %>% 
    group_by(fid, mapper, conversion_rate, classification, true_isoform, mappability, ftype) %>% 
    summarise(all=sum(count), 
              tc1=sum(count[cv1==1]), 
              tc2=sum(count[cv2==1])) %>% 
    pivot_wider(names_from=classification, values_from=c(all, tc1, tc2), names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      all_true =  all_TP+all_FN,
      all_found = all_TP+all_FP,
      tc1_true =  tc1_TP+tc1_FN,
      tc1_found = tc1_TP+tc1_FP,
      tc2_true =  tc2_TP+tc2_FN,
      tc2_found = tc2_TP+tc2_FP,
      true_fcr1 = ifelse(all_true>0,tc1_true/all_true,0),
      found_fcr1 = ifelse(all_found>0,tc1_found/all_found,0),
      true_fcr2 = ifelse(all_true>0,tc2_true/all_true,0),
      found_fcr2 = ifelse(all_found>0,tc2_found/all_found,0),
      # performance
      all_precision=ifelse(all_TP+all_FP>0, all_TP/(all_TP+all_FP), NA),
      all_recall=ifelse(all_TP+all_FN>0,all_TP/(all_TP+all_FN), NA),
      all_F1=ifelse((2*all_TP+all_FP+all_FN)>0,2*all_TP/(2*all_TP+all_FP+all_FN),NA),
      tc1_precision=ifelse(tc1_TP+tc1_FP>0, tc1_TP/(tc1_TP+tc1_FP), NA),
      tc1_recall=ifelse(tc1_TP+tc1_FN>0,tc1_TP/(tc1_TP+tc1_FN), NA),
      tc1_F1=ifelse((2*tc1_TP+tc1_FP+tc1_FN)>0,2*tc1_TP/(2*tc1_TP+tc1_FP+tc1_FN),NA),
      tc2_precision=ifelse(tc2_TP+tc2_FP>0, tc2_TP/(tc2_TP+tc2_FP), NA),
      tc2_recall=ifelse(tc2_TP+tc2_FN>0,tc2_TP/(tc2_TP+tc2_FN), NA),
      tc2_F1=ifelse((2*tc2_TP+tc2_FP+tc2_FN)>0,2*tc2_TP/(2*tc2_TP+tc2_FP+tc2_FN),NA)
  ) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron')))
}, 'fcr', rerun=F)

# fcr %>% 
#   filter(mapper=='STAR') %>% 
#   ggplot(aes(conversion_rate, true_fcr1, alpha=0.1)) +
#   geom_boxplot() +
#   facet_grid(true_isoform~ftype+mappability) +
#   ggtitle("QC: Simulated fcr per conversion rate")

fcr_perf = cache({
  fcr %>%
    select(fid, conversion_rate,true_isoform,ftype,mappability,true_fcr1, found_fcr1) %>% 
    ungroup() %>% 
    pivot_wider(names_from=mapper, values_from=c(true_fcr1, found_fcr1)) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>%   # replace NA with 0; NA are resulting from mat not having introns. So if there are no FP values then there are no entries!
    rename(simulated=true_fcr1_HISAT3N, HISAT3N=found_fcr1_HISAT3N, STAR=found_fcr1_STAR) %>%
    select(-true_fcr1_STAR) %>% 
    mutate(diff_HISAT3N=HISAT3N-simulated, 
           diff_STAR=STAR-simulated,
           best_diff=pmin(abs(diff_HISAT3N), abs(diff_STAR)),
           best_mapper=case_when(
             best_diff>0.1 ~ 'None',
             abs(diff_HISAT3N)<0.05 & abs(diff_STAR)<0.05 ~ 'Both',
             abs(diff_HISAT3N)<abs(diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
           )
}, 'fcr_perf', rerun=F)

# result tables
fcr_tab = fcr_perf %>% 
  filter(as.numeric(as.character(conversion_rate))>0) %>% 
  group_by(fid, ftype) %>% 
  summarise(m_diff_HISAT3N = mean(diff_HISAT3N,na.rm=T), 
            m_diff_STAR = mean(diff_STAR,na.rm=T)) %>% 
  mutate(best_m_diff=pmin(abs(m_diff_HISAT3N), abs(m_diff_STAR)),
         best_mapper=case_when(
             best_m_diff>0.1 ~ 'None',
             abs(m_diff_HISAT3N)<0.05 & abs(m_diff_STAR)<0.05 ~ 'Both',
             abs(m_diff_HISAT3N)<abs(m_diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
         )

fcr3g = cache({
  tx3g %>% 
    bind_rows(fx3g) %>% 
    group_by(fid, mapper, conversion_rate, classification, true_isoform, mappability, ftype) %>% 
    summarise(all=sum(count), 
              tc1=sum(count[cv1==1]), 
              tc2=sum(count[cv2==1])) %>% 
    pivot_wider(names_from=classification, values_from=c(all, tc1, tc2), names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      all_true =  all_TP+all_FN,
      all_found = all_TP+all_FP,
      tc1_true =  tc1_TP+tc1_FN,
      tc1_found = tc1_TP+tc1_FP,
      tc2_true =  tc2_TP+tc2_FN,
      tc2_found = tc2_TP+tc2_FP,
      true_fcr1 = ifelse(all_true>0,tc1_true/all_true,0),
      found_fcr1 = ifelse(all_found>0,tc1_found/all_found,0),
      true_fcr2 = ifelse(all_true>0,tc2_true/all_true,0),
      found_fcr2 = ifelse(all_found>0,tc2_found/all_found,0),
      # performance
      all_precision=ifelse(all_TP+all_FP>0, all_TP/(all_TP+all_FP), NA),
      all_recall=ifelse(all_TP+all_FN>0,all_TP/(all_TP+all_FN), NA),
      all_F1=ifelse((2*all_TP+all_FP+all_FN)>0,2*all_TP/(2*all_TP+all_FP+all_FN),NA),
      tc1_precision=ifelse(tc1_TP+tc1_FP>0, tc1_TP/(tc1_TP+tc1_FP), NA),
      tc1_recall=ifelse(tc1_TP+tc1_FN>0,tc1_TP/(tc1_TP+tc1_FN), NA),
      tc1_F1=ifelse((2*tc1_TP+tc1_FP+tc1_FN)>0,2*tc1_TP/(2*tc1_TP+tc1_FP+tc1_FN),NA),
      tc2_precision=ifelse(tc2_TP+tc2_FP>0, tc2_TP/(tc2_TP+tc2_FP), NA),
      tc2_recall=ifelse(tc2_TP+tc2_FN>0,tc2_TP/(tc2_TP+tc2_FN), NA),
      tc2_F1=ifelse((2*tc2_TP+tc2_FP+tc2_FN)>0,2*tc2_TP/(2*tc2_TP+tc2_FP+tc2_FN),NA)
  ) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron')))
}, 'fcr3g', rerun=F)

# fcr %>% 
#   filter(mapper=='STAR') %>% 
#   ggplot(aes(conversion_rate, true_fcr1, alpha=0.1)) +
#   geom_boxplot() +
#   facet_grid(true_isoform~ftype+mappability) +
#   ggtitle("QC: Simulated fcr per conversion rate")

fcr_perf3g = cache({
  fcr3g %>%
    select(fid, conversion_rate,true_isoform,ftype,mappability,true_fcr1, found_fcr1) %>% 
    ungroup() %>% 
    pivot_wider(names_from=mapper, values_from=c(true_fcr1, found_fcr1)) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>%   # replace NA with 0; NA are resulting from mat not having introns. So if there are no FP values then there are no entries!
    rename(simulated=true_fcr1_HISAT3N, HISAT3N=found_fcr1_HISAT3N, STAR=found_fcr1_STAR) %>%
    select(-true_fcr1_STAR) %>% 
    mutate(diff_HISAT3N=HISAT3N-simulated, 
           diff_STAR=STAR-simulated,
           best_diff=pmin(abs(diff_HISAT3N), abs(diff_STAR)),
           best_mapper=case_when(
             best_diff>0.1 ~ 'None',
             abs(diff_HISAT3N)<0.05 & abs(diff_STAR)<0.05 ~ 'Both',
             abs(diff_HISAT3N)<abs(diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
           )
}, 'fcr_perf3g', rerun=F)

# result tables
fcr_tab3g = fcr_perf3g %>% 
  filter(as.numeric(as.character(conversion_rate))>0) %>% 
  group_by(fid, ftype) %>% 
  summarise(m_diff_HISAT3N = mean(diff_HISAT3N,na.rm=T), 
            m_diff_STAR = mean(diff_STAR,na.rm=T)) %>% 
  mutate(best_m_diff=pmin(abs(m_diff_HISAT3N), abs(m_diff_STAR)),
         best_mapper=case_when(
             best_m_diff>0.1 ~ 'None',
             abs(m_diff_HISAT3N)<0.05 & abs(m_diff_STAR)<0.05 ~ 'Both',
             abs(m_diff_HISAT3N)<abs(m_diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
         )

fcr3t = cache({
  tx3t %>% 
    bind_rows(fx3t) %>% 
    group_by(fid, mapper, conversion_rate, classification, true_isoform, mappability, ftype) %>% 
    summarise(all=sum(count), 
              tc1=sum(count[cv1==1]), 
              tc2=sum(count[cv2==1])) %>% 
    pivot_wider(names_from=classification, values_from=c(all, tc1, tc2), names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      all_true =  all_TP+all_FN,
      all_found = all_TP+all_FP,
      tc1_true =  tc1_TP+tc1_FN,
      tc1_found = tc1_TP+tc1_FP,
      tc2_true =  tc2_TP+tc2_FN,
      tc2_found = tc2_TP+tc2_FP,
      true_fcr1 = ifelse(all_true>0,tc1_true/all_true,0),
      found_fcr1 = ifelse(all_found>0,tc1_found/all_found,0),
      true_fcr2 = ifelse(all_true>0,tc2_true/all_true,0),
      found_fcr2 = ifelse(all_found>0,tc2_found/all_found,0),
      # performance
      all_precision=ifelse(all_TP+all_FP>0, all_TP/(all_TP+all_FP), NA),
      all_recall=ifelse(all_TP+all_FN>0,all_TP/(all_TP+all_FN), NA),
      all_F1=ifelse((2*all_TP+all_FP+all_FN)>0,2*all_TP/(2*all_TP+all_FP+all_FN),NA),
      tc1_precision=ifelse(tc1_TP+tc1_FP>0, tc1_TP/(tc1_TP+tc1_FP), NA),
      tc1_recall=ifelse(tc1_TP+tc1_FN>0,tc1_TP/(tc1_TP+tc1_FN), NA),
      tc1_F1=ifelse((2*tc1_TP+tc1_FP+tc1_FN)>0,2*tc1_TP/(2*tc1_TP+tc1_FP+tc1_FN),NA),
      tc2_precision=ifelse(tc2_TP+tc2_FP>0, tc2_TP/(tc2_TP+tc2_FP), NA),
      tc2_recall=ifelse(tc2_TP+tc2_FN>0,tc2_TP/(tc2_TP+tc2_FN), NA),
      tc2_F1=ifelse((2*tc2_TP+tc2_FP+tc2_FN)>0,2*tc2_TP/(2*tc2_TP+tc2_FP+tc2_FN),NA)
  ) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron')))
}, 'fcr3t', rerun=F)

# fcr %>% 
#   filter(mapper=='STAR') %>% 
#   ggplot(aes(conversion_rate, true_fcr1, alpha=0.1)) +
#   geom_boxplot() +
#   facet_grid(true_isoform~ftype+mappability) +
#   ggtitle("QC: Simulated fcr per conversion rate")

fcr_perf3t = cache({
  fcr3t %>%
    select(fid, conversion_rate,true_isoform,ftype,mappability,true_fcr1, found_fcr1) %>% 
    ungroup() %>% 
    pivot_wider(names_from=mapper, values_from=c(true_fcr1, found_fcr1)) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>%   # replace NA with 0; NA are resulting from mat not having introns. So if there are no FP values then there are no entries!
    rename(simulated=true_fcr1_HISAT3N, HISAT3N=found_fcr1_HISAT3N, STAR=found_fcr1_STAR) %>%
    select(-true_fcr1_STAR) %>% 
    mutate(diff_HISAT3N=HISAT3N-simulated, 
           diff_STAR=STAR-simulated,
           best_diff=pmin(abs(diff_HISAT3N), abs(diff_STAR)),
           best_mapper=case_when(
             best_diff>0.1 ~ 'None',
             abs(diff_HISAT3N)<0.05 & abs(diff_STAR)<0.05 ~ 'Both',
             abs(diff_HISAT3N)<abs(diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
           )
}, 'fcr_perf3t', rerun=F)

# result tables
fcr_tab3t = fcr_perf3t %>% 
  filter(as.numeric(as.character(conversion_rate))>0) %>% 
  group_by(fid, ftype) %>% 
  summarise(m_diff_HISAT3N = mean(diff_HISAT3N,na.rm=T), 
            m_diff_STAR = mean(diff_STAR,na.rm=T)) %>% 
  mutate(best_m_diff=pmin(abs(m_diff_HISAT3N), abs(m_diff_STAR)),
         best_mapper=case_when(
             best_m_diff>0.1 ~ 'None',
             abs(m_diff_HISAT3N)<0.05 & abs(m_diff_STAR)<0.05 ~ 'Both',
             abs(m_diff_HISAT3N)<abs(m_diff_STAR) ~ 'HISAT3N',
             T ~ 'STAR')
         )

```

### FCR per condition

<div class = "blue">
<b>Fraction of converted reads.</b>
Fraction of converted reads (fcr), stratified by feature type and originating isoform.
Note that HISAT3N and STAR tend to slightly over- respctively underestimate FCR in exonic regions.
The non-zero FCR for mature introns results from false-positive intronic reads.

</div>

```{r fcr_perf, include=T, echo=F, cache=T}

pdf(paste0(params$out_dir, 'fcr_perf.pdf'), width=12, height=10)

fcr_perf %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition',subtitle="Full-length tx") +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(true_isoform~ftype)

fcr_perf3g %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition',subtitle="3'end genomic") +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(true_isoform~ftype)

fcr_perf3t %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition',subtitle="3'end transcriptomic") +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(true_isoform~ftype)

fcrCompareTab = rbind(
  fcr_perf %>% dplyr::mutate(tech = "gn"),
  fcr_perf3g %>% dplyr::mutate(tech = "3end_gn"),
  fcr_perf3t %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

fcrCompareTab %>%
  dplyr::filter(ftype == "tx") %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(tech,conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(tech~true_isoform)

toi = convertibilityClassAlluvia %>% dplyr::filter(gn == "low" & `3end_gn` == "high") %>% .$tid

fcrCompareTab = rbind(
  fcr_perf %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "gn"),
  fcr_perf3g %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_gn"),
  fcr_perf3t %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

fcrCompareTab %>%
  dplyr::filter(ftype == "tx") %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(tech,conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition for low genome high 3end convertibility') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(tech~true_isoform)

toi = convertibilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_gn` == "low") %>% .$tid

fcrCompareTab = rbind(
  fcr_perf %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "gn"),
  fcr_perf3g %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_gn"),
  fcr_perf3t %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

fcrCompareTab %>%
  dplyr::filter(ftype == "tx") %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(tech,conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition for high genome low 3end convertibility') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(tech~true_isoform)

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "low" & `3end_gn` == "high") %>% .$tid

fcrCompareTab = rbind(
  fcr_perf %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "gn"),
  fcr_perf3g %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_gn"),
  fcr_perf3t %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

fcrCompareTab %>%
  dplyr::filter(ftype == "tx") %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(tech,conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition for low genome high 3end mappability') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(tech~true_isoform)

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_gn` == "low") %>% .$tid

fcrCompareTab = rbind(
  fcr_perf %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "gn"),
  fcr_perf3g %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_gn"),
  fcr_perf3t %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

fcrCompareTab %>%
  dplyr::filter(ftype == "tx") %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(tech,conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition for high genome low 3end genomic mappability') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(tech~true_isoform)

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_tx` == "low") %>% .$tid

fcrCompareTab = rbind(
  fcr_perf %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "gn"),
  fcr_perf3g %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_gn"),
  fcr_perf3t %>% dplyr::filter(fid %in% toi) %>% dplyr::mutate(tech = "3end_tx")
) %>%
  dplyr::mutate(tech = factor(tech, levels = c("gn","3end_gn","3end_tx")))

fcrCompareTab %>%
  dplyr::filter(ftype == "tx") %>%
  pivot_longer(c(simulated,HISAT3N, STAR)) %>% 
  mutate(name=factor(name, levels=c('simulated', 'STAR', 'HISAT3N'))) %>% 
  group_by(tech,conversion_rate,true_isoform,ftype, name) %>% 
  calc_ci(value) %>% 
  ggplot(aes(x=as.numeric(as.character(conversion_rate))*100, y=col.mean, col=name, group=name, linetype=name)) + 
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  geom_line() +
  ggtitle('Mean FCR per condition for high genome low 3end transcriptomic mappability') +
  scale_x_continuous() + xlab("conversion rate [%]") + ylab("Mean FCR") +
  facet_grid(tech~true_isoform)

dev.off()

```

### FCR best mapper
<div class = "blue">
<b>Best mapper counts.</b>
Number of times a mapper 

</div>
```{r fcr_best_mapper, include=T, echo=F, cache=T}

pdf(paste0(params$out_dir, 'fcr_best_sequencing_technology.pdf'), width=12, height=10)

cross_fcr_perf = fcr_perf %>%
  dplyr::select(fid, conversion_rate, true_isoform, ftype, best_diff) %>%
  dplyr::rename(best_diff_gn = best_diff) %>% 
  dplyr::full_join(fcr_perf3g %>%
                     dplyr::select(fid, conversion_rate, true_isoform, ftype,best_diff) %>%
                     dplyr::rename(best_diff_3gn = best_diff)
  ) %>%
  dplyr::full_join(fcr_perf3t %>%
                     dplyr::select(fid, conversion_rate, true_isoform, ftype,best_diff) %>%
                     dplyr::rename(best_diff_3t = best_diff)
  )

cross_fcr_perf %>% 
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(best_diff_gn, best_diff_3gn, best_diff_3t)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.01, 0.01)) +
  ggtitle('FCR difference to simulated values per mapper (mat isoform)')

toi = convertibilityClassAlluvia %>% dplyr::filter(gn == "low" & `3end_gn` == "high") %>% .$tid

cross_fcr_perf %>% 
  dplyr::filter(fid %in% toi) %>%
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(best_diff_gn, best_diff_3gn, best_diff_3t)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.001, 0.001)) +
  ggtitle('FCR difference to simulated values per mapper (mat isoform)', subtitle = "Low genomic convertibility, high 3'end convertibility")

toi = convertibilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_gn` == "low") %>% .$tid

cross_fcr_perf %>% 
  dplyr::filter(fid %in% toi) %>%
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(best_diff_gn, best_diff_3gn, best_diff_3t)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.01, 0.01)) +
    ggtitle('FCR difference to simulated values per mapper (mat isoform)', subtitle = "High genomic convertibility, low 3'end convertibility")

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "low" & `3end_gn` == "high") %>% .$tid

cross_fcr_perf %>% 
  dplyr::filter(fid %in% toi) %>%
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(best_diff_gn, best_diff_3gn, best_diff_3t)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.01, 0.01)) +
  ggtitle('FCR difference to simulated values per mapper (mat isoform)', subtitle = "Low genomic mappability, high 3'end mappability")

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_gn` == "low") %>% .$tid

cross_fcr_perf %>% 
  dplyr::filter(fid %in% toi) %>%
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(best_diff_gn, best_diff_3gn, best_diff_3t)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.1, 0.1)) +
  ggtitle('FCR difference to simulated values per mapper (mat isoform)', subtitle = "High genomic mappability, low 3'end mappability")

toi = mappabilityClassAlluvia %>% dplyr::filter(gn == "high" & `3end_tx` == "low") %>% .$tid

cross_fcr_perf %>% 
  dplyr::filter(fid %in% toi) %>%
  filter(ftype=='tx', true_isoform=='mat') %>% 
  pivot_longer(c(best_diff_gn, best_diff_3gn, best_diff_3t)) %>% 
  ggplot(aes(x=conversion_rate, y=value, col=name)) +
  geom_boxplot() +
  facet_zoom(ylim=c(-0.1, 0.1)) +
  ggtitle('FCR difference to simulated values per mapper (mat isoform)', subtitle = "High genomic mappability, low 3'end transcriptome mappability")

dev.off()

```

### FCR result tables
```{r fcr_results, include=T, echo=F, cache=T}
results[['fcr_tx_tab']] = fcr_tab %>% filter(ftype=='tx') %>%
  rename(tid=fid) %>% 
  left_join(m[['tx']], by=c('tid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['fcr_ex_tab']] = fcr_tab %>% filter(ftype=='exon') %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 

results[['fcr_in_tab']] = fcr_tab %>% filter(ftype=='intron') %>% 
  left_join(m[['fx']], by=c('fid', 'ftype')) %>% 
  left_join(m[['ga']], by=c('tid')) 
```

# Special analyses

## Performance of converted vs unconverted reads


<div class = "blue">
<b>Fraction of false positive/negative reads stratified by nucleotide mismatches.</b>
We expected the fraction of FP/FN reads to increase with increasing mismatches to the reference sequence that can stem from simulated nucleotide conversions or sequencing errors. 

The plots show an increased rate of FP/FN reads in HISAT3N vs STAR.

HISAT3N should be less/not influenced by nucleotide conversions (as these are masked from the reference genome).
</div>

```{r, include = F}
calc_fcr_cvsu = function(tab) {
  tab %>% 
    group_by( mapper, classification, ftype, mappability) %>% 
    summarise(all=sum(count),
              cv_0=sum(count[(cv1==0) & (cv2==0)]), # reads with no tc conv
              cv_1=sum(count[(cv1==1) & (cv2==0)]), # reads with 1 tc conv
              cv_2=sum(count[cv2==1]), # reads with 2+ tc conv
              se_0=sum(count[(se1==0) & (se2==0)]), # reads with no seq err
              se_1=sum(count[(se1==1) & (se2==0)]), # reads with 1 seq err
              se_2=sum(count[(se2==1)])) %>% # reads with 2+ seq err
    pivot_wider(names_from=classification, 
                values_from=c(all, cv_0,cv_1,cv_2, se_0,se_1,se_2), 
                names_sort=T) %>% 
    mutate(across(where(is.numeric), ~ifelse(is.nan(.) | is.na(.), 0, .))) %>% 
    mutate(
      cv_0_fn_frac=ifelse(cv_0_TP+cv_0_FN>0,cv_0_FN/(cv_0_TP+cv_0_FN),NA),
      cv_1_fn_frac=ifelse(cv_1_TP+cv_1_FN>0,cv_1_FN/(cv_1_TP+cv_1_FN),NA),
      cv_2_fn_frac=ifelse(cv_2_TP+cv_2_FN>0,cv_2_FN/(cv_2_TP+cv_2_FN),NA),
      se_0_fn_frac=ifelse(se_0_TP+se_0_FN>0,se_0_FN/(se_0_TP+se_0_FN),NA),
      se_1_fn_frac=ifelse(se_1_TP+se_1_FN>0,se_1_FN/(se_1_TP+se_1_FN),NA),
      se_2_fn_frac=ifelse(se_2_TP+se_2_FN>0,se_2_FN/(se_2_TP+se_2_FN),NA),
      # FP rate
      cv_0_fp_frac=ifelse(cv_0_TP+cv_0_FP>0,cv_0_FP/(cv_0_TP+cv_0_FP),NA),
      cv_1_fp_frac=ifelse(cv_1_TP+cv_1_FP>0,cv_1_FP/(cv_1_TP+cv_1_FP),NA),
      cv_2_fp_frac=ifelse(cv_2_TP+cv_2_FP>0,cv_2_FP/(cv_2_TP+cv_2_FP),NA),
      se_0_fp_frac=ifelse(se_0_TP+se_0_FP>0,se_0_FP/(se_0_TP+se_0_FP),NA),
      se_1_fp_frac=ifelse(se_1_TP+se_1_FP>0,se_1_FP/(se_1_TP+se_1_FP),NA),
      se_2_fp_frac=ifelse(se_2_TP+se_2_FP>0,se_2_FP/(se_2_TP+se_2_FP),NA)
  ) %>% 
#  filter_at(vars(tc_0_fn_frac, tc_1_fn_frac, tc_2_fn_frac), all_vars(!is.na(.))) %>% # values in all categories
  pivot_longer(cols=ends_with('frac')) %>%
  separate(name, into=c('cat','n_conv','class',NA), sep ='_')  %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
  mutate(n_conv=factor(ifelse(n_conv==2, '2+', as.character(n_conv)), levels=c('0','1','2+')))
}

fcr_cvsu = calc_fcr_cvsu(tx)


p1=fcr_cvsu %>% 
  filter(cat=='se', class=='fn') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('sequencing errors, FN') +
  ylab("#FN / (#TP + #FN)")
p2=fcr_cvsu %>% 
  filter(cat=='se', class=='fp') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('sequencing errors, FP') +
  ylab("#FP / (#TP + #FP)")
p3=fcr_cvsu %>% 
  filter(cat=='cv', class=='fn') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('nucleotide conversions, FN') +
  ylab("#FN / (#TP + #FN)")
p4=fcr_cvsu %>% 
  filter(cat=='cv', class=='fp') %>% 
  ggplot(aes(n_conv, value, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(mappability~mapper, scales = 'free') +
  ggtitle('nucleotide conversions, FP') +
  ylab("#FP / (#TP + #FP)")
my_plot_grid(list(p1,p2,p3,p4), nrow=2, 'FN/FP fraction dependence on mismatches')

ggsave(paste0(params$out_dir, 'special_conv_unconv_reads.pdf'), width=12, height=10)
```

## MQ20 Mapping quality filtering

Demonstrate effect of mq20 filtering on coverage and mapping F1.

```{r, include=F}

comp_cov=function(a,b, grp_vars) {
  sel_vars=grp_vars[grp_vars!='classification']
  calc_coverage(a %>% group_by_at(grp_vars) ) %>% 
    select(any_of(c(sel_vars, 'value'))) %>% 
    left_join(
      calc_coverage(b %>% group_by_at(grp_vars) ) %>% 
        select(any_of(c(sel_vars, 'value'))),
      by=sel_vars, suffix = c(".mq0", ".mq20"),
    )
}

cov_comp_tx = comp_cov(tx, tx20, c('mapper', 'conversion_rate', 'fid', 'len', 'classification' ))
cov_comp_fx = comp_cov(fx, fx20, c('mapper', 'conversion_rate', 'fid', 'true_isoform', 'ftype', 'len', 'classification' )) 
# sanity check: 
#testthat::expect_that(cov_comp_tx %>% filter(value.mq20>value.mq0) %>% nrow(), equals(0))
#testthat::expect_that(cov_comp_fx %>% filter(value.mq20>value.mq0) %>% nrow(), equals(0))
#cov_comp_fx %>% mutate(comp=(value.mq0 > value.mq20) - (value.mq0 < value.mq20)) %>% count(comp)


p1 = cov_comp_tx %>% 
  pivot_longer(c(value.mq0, value.mq20), names_prefix='value.', names_to='mq') %>% 
  replace_na(list(value = 0)) %>% 
  ggplot(aes(x=mapper, y=value, fill=factor(mq))) + geom_boxplot() +
  scale_y_sqrt() +
  #facet_grid(conversion_rate~., scales = 'free') +
  ggtitle('Coverage over tx interval') + 
  xlab('') + ylab('coverage') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  guides(fill=guide_legend(title="Min mapping quality"))


p2 = cov_comp_fx %>% 
  pivot_longer(c(value.mq0, value.mq20), names_prefix='value.', names_to='mq') %>% 
  replace_na(list(value = 0)) %>% # some mq20 entries have no counts in any classification leading to NAs
  ggplot(aes(x=mapper, y=value, fill=factor(mq))) + geom_boxplot() +
  scale_y_sqrt() +
  ggtitle('Coverage per genomic feature') +
  facet_grid(true_isoform~ftype, scales = 'free') + 
  xlab('') + ylab('coverage') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  guides(fill=guide_legend(title="Min mapping quality"))

p3=cov_comp_fx %>% 
  group_by(mapper, conversion_rate, true_isoform, ftype ) %>% 
  summarise(mq0=sum(value.mq0),
            mq20=sum(value.mq20, na.rm = T),
            frac_fil=ifelse(mq0>0,(mq0-mq20)/mq0,0)) %>% 
  ggplot(aes(conversion_rate, frac_fil, col=mapper, group=mapper)) +
  geom_line() +
  facet_grid(true_isoform~ftype, scales = 'free') +
  ggtitle("Fraction of mq20 filtered reads per genomic feature")


perf_comp = tx %>% bind_rows(fx) %>% 
  group_by(mapper, conversion_rate, mappability, len, classification,true_isoform,ftype) %>% 
  calc_performance(conf$readlen) %>% 
  mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
  filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
  ungroup() %>% 
  select(mapper, conversion_rate, mappability,true_isoform,ftype,F1.mq0=F1) %>% 
  left_join(
    tx20 %>% bind_rows(fx20) %>% 
    group_by(mapper, conversion_rate, mappability, len, classification,true_isoform,ftype) %>% 
    calc_performance(conf$readlen) %>% 
    mutate(ftype=factor(ftype, levels=c('tx', 'exon', 'intron'))) %>% 
    filter(!(ftype=='intron' & true_isoform=='mat')) %>% # undefined and always 0!
    ungroup() %>% 
    select(mapper, conversion_rate, mappability,true_isoform,ftype,F1.mq20=F1),
    by=c('mapper', 'conversion_rate', 'mappability', 'true_isoform','ftype')
  )

p4 = perf_comp %>% 
  pivot_longer(c(F1.mq0, F1.mq20), names_prefix='F1.', names_to='mq', values_to='F1') %>% 
  group_by(conversion_rate, mapper, mappability, true_isoform, ftype, mq) %>% 
  calc_ci(F1) %>% 
  ggplot(aes(conversion_rate, col.mean, col=mapper, group=paste0(mapper,true_isoform), linetype=true_isoform)) +
  geom_line() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype+mq, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Mean F1 for mature isoforms per condition based on mq20/unfiltered read counts') 


p4 = perf_comp %>% 
  pivot_longer(c(F1.mq0, F1.mq20), names_prefix='F1.', names_to='mq', values_to='F1') %>% 
  group_by(conversion_rate, mapper, mappability, true_isoform, ftype, mq) %>% 
  calc_ci(F1) %>% 
  ggplot(aes(mapper, col.mean, col=mq, group=paste0(mapper,mq))) +
  geom_boxplot() +
  #geom_ribbon(aes(ymin=col.lower, ymax=col.upper), linetype=2, alpha=0.2) +
  facet_grid(mappability~ftype+true_isoform, scales = 'free') +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "genomic mappability", breaks = NULL, labels = NULL)) +
  theme(axis.title.y.right = element_text(angle=-90, vjust = 1.5))+
  ylab("F1") +
  ggtitle('Mean F1 for mature isoforms per condition based on mq20/unfiltered read counts') 

 my_plot_grid(list(p1,p2,p3,p4), labels = T, 'Coverage of mapping-quality filtered reads')
 
```

# Write results tables
```{r, include=F}

# build summary table per tx
tab_summary =
  results[['map_tx_tab']] %>% select(gene_name, tid, mappability,
                                     map_best_no_conv=best_mapper_no_conv, 
                                     map_best_conv=best_mapper_conv) %>% 
  full_join(
    results[['fcr_tx_tab']] %>% select(gene_name, tid, 
                                       fcr_best=best_mapper), 
    by=c('gene_name', 'tid' )) %>% 
  full_join(
    results[['spl_tx_tab']] %>% select(gene_name, tid, 
                                       spl_best=best_mapper_fmat), 
    by=c('gene_name', 'tid' )) 
  
results=c(list('summary'=tab_summary), results)

tab_summary %>% 
  rename(MAP=map_best_no_conv, MAP_CONV=map_best_conv, FCR=fcr_best, FMAT=spl_best) %>% 
  pivot_longer(c(MAP, MAP_CONV, FCR, FMAT), values_to='mapper' ) %>% 
  group_by(name, mapper, mappability) %>% 
  count() %>% 
  mutate(name=factor(name, levels=c('MAP', 'MAP_CONV', 'FCR', 'FMAT')),
         mapper=factor(toupper(mapper), levels=c('BOTH', 'STAR', 'HISAT3N'))) %>% 
  ggplot(aes(mapper, n, fill=mapper)) +
    geom_bar(stat='identity') +
    facet_grid(mappability~name, scales = 'free') +
    ggtitle('Best mapper per category') +
    scale_x_discrete(drop = FALSE) +
    scale_fill_discrete(drop=FALSE) +
    ylab("number of transcripts") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggsave(paste0(params$out_dir, 'Best_mapper_summary.pdf'), width=12, height=10)

# write excel result file
write_xlsx(results, path=paste0(params$out_dir, 'map.xlsx'))
```