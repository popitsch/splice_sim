---
title: "splice_sim_slamdunk.Rmd"
author: "tobias.neumann@imp.ac.at"
documentclass: article
fontsize: 10pt
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 14
    fig_height: 10
    fig_caption: true
    df_print: paged
  pdf_document:
    fig_width: 12
    fig_height: 10
    fig_caption: true
params:
    slamdunk_eva:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/slamdunk_big4_slamseq_3ends/results/slamdunk/eva/"
    out_dir:
       value: "/groups/zuber/zubarchive/USERS/tobias/myProjects/slamdunk/splice_sim/slamdunk_big4_slamseq_3ends/analysis/"
---
<style type="text/css">
body, td {
   font-size: 10px;
}
code.r{
  font-size: 10px;
}
pre {
  font-size: 10px
}
div.blue pre { background-color:lightblue; }
div.blue pre.r { background-color:blue; }
</style>

<!--
rmarkdown::render('splice_sim_paper.Rmd', 'html_document')
-->

# INIT

```{r setup, include=FALSE}
require(data.table)
require(tidyr)
require(dplyr)
require(ggplot2)
require(scales)
require(rjson)
require(stringr)
require(VGAM)
require(cowplot)
require(arrow)
require(tictoc)
require(ggpubr)
require(minpack.lm)
require(readr)
require(testthat)
require(RColorBrewer)
require(skimr)
require(ggforce)
require(writexl)
require(xfun)
require(forcats)
require(glue)
# NB install arrow with snappy on Rstudio server
# Sys.setenv(ARROW_WITH_SNAPPY = "ON")
# Sys.setenv(NOT_CRAN="true")
# Sys.setenv(LIBARROW_BINARY="FALSE")
# install.packages("arrow", repos = "https://arrow-r-nightly.s3.amazonaws.com")

# to ensure stripping '\0' (nul) from character vector
options(arrow.skip_nul = TRUE)

# global theme
ggplot2::theme_set(theme_light())

# enable tidylog (has overhead!)
#require(tidylog)
options("tidylog.display" = list()) # turn tidylog off
options(scipen=10000) # to avoid scientific notation y axis 

# load resoiutces/functions
source('splice_sim_resources.R')
```


# data

```{r data, include=T, echo=F, eval=T}

home_dir=params$slamdunk_eva
# create result dir?
if (!dir.exists(params$out_dir)) {
  dir.create(params$out_dir)
} 
if (!dir.exists(paste0(params$out_dir,'/cache/'))) {
  dir.create(paste0(params$out_dir,'/cache/'))
}

samples = list.files(home_dir,pattern="splice_sim_eva.txt")

sampleName = sub("_splice_sim_eva.txt","",samples[1])
cr = sub(".*\\.cr","",sampleName)
tech = sub(".*_","",cr)
cr = sub("_.*","",cr)

if (tech == cr) {
  tech = "full_length"
}

masterTable = read_tsv(paste0(home_dir, samples[1]))

masterTable = masterTable %>%
  dplyr::mutate(cr = cr, tech = tech)

for (i in 2:length(samples)) {
  
  sampleName = sub("_splice_sim_eva.txt","",samples[i])
  cr = sub(".*\\.cr","",sampleName)
  tech = sub(".*_","",cr)
  cr = sub("_.*","",cr)
  
  if (tech == cr) {
    tech = "full_length"
  }
  
  tmpTab = read_tsv(paste0(home_dir, samples[i]))
  
  tmpTab = tmpTab %>%
    dplyr::mutate(cr = cr, tech = tech)
  
  masterTable = masterTable %>%
    bind_rows(tmpTab)
}

```

### Slamdunk stats

We mapped our reads with Slamdunk and get T>C conversion numbers per read. We can now compare these numbers to the simulated T>C conversions in a read and do this across all 3' ends.

```{r missing_tids, include=T, echo=F}

masterTable %>%
  ggplot(aes(x = cr, y = mean_detected_vs_simulated_conversions, fill = tech)) +
  geom_violin() +
  geom_boxplot(outlier.shape = NA,width=0.05) +
  theme(
    legend.title=element_blank()
  ) +
  ylim(-0.25,0.25) + xlab("Conversion rate") +
  ylab("Mean delta detected vs simulated conversions") +
  scale_fill_brewer(palette = "Set2") + ggtitle("Exons")

masterTable %>%
  ggplot(aes(x = tech, y = mean_detected_vs_simulated_conversions, fill = tech)) +
  geom_violin() +
  geom_boxplot(outlier.shape = NA,width=0.05) +
  theme(
    legend.position="none"
  ) +
  facet_wrap(~cr,nrow=1) +
  ylim(-0.25,0.25) + xlab("Sequencing technology") +
  ylab("Mean delta detected vs simulated conversions") +
  scale_fill_brewer(palette = "Set2") + ggtitle("Exons")

masterTable %>%
  dplyr::group_by(cr, tech, tx_id) %>%
  dplyr::arrange(cr, tech, tx_id) %>%
  dplyr::left_join(
    masterTable %>%
      dplyr::group_by(cr, tech, tx_id) %>%
      dplyr::arrange(cr, tech, tx_id) %>% 
      dplyr::summarise(total_reads = sum(reads_per_feature))
  ) %>%
  dplyr::mutate(weight = reads_per_feature / total_reads) %>%
  dplyr::summarise(weighted_mean = sum(mean_detected_vs_simulated_conversions * weight)) %>%
  ggplot(aes(x = cr, y = weighted_mean, fill = tech)) +
  geom_violin() +
  geom_boxplot(outlier.shape = NA,width=0.05) +
  theme(
    legend.title=element_blank()
  ) +
  ylim(-0.25,0.25) + xlab("Conversion rate") +
  ylab("Mean delta detected vs simulated conversions") +
  scale_fill_brewer(palette = "Set2") + ggtitle("Transcripts")

masterTable %>%
  dplyr::group_by(cr, tech, tx_id) %>%
  dplyr::arrange(cr, tech, tx_id) %>%
  dplyr::left_join(
    masterTable %>%
      dplyr::group_by(cr, tech, tx_id) %>%
      dplyr::arrange(cr, tech, tx_id) %>% 
      dplyr::summarise(total_reads = sum(reads_per_feature))
  ) %>%
  dplyr::mutate(weight = reads_per_feature / total_reads) %>%
  dplyr::summarise(weighted_mean = sum(mean_detected_vs_simulated_conversions * weight)) %>%
  ggplot(aes(x = tech, y = weighted_mean, fill = tech)) +
  geom_violin() +
  geom_boxplot(outlier.shape = NA,width=0.05) +
  theme(
    legend.position="none"
  ) +
  facet_wrap(~cr,nrow=1) +
  ylim(-0.25,0.25) + xlab("Sequencing technology") +
  ylab("Mean delta detected vs simulated conversions") +
  scale_fill_brewer(palette = "Set2") + ggtitle("Transcripts")

#my_plot_grid(list(p1,p2,p3), labels=T, 'QC only', nrow = 1)
#ggsave(paste0(params$out_dir, 'qc_missing_tids.pdf'), width=12, height=10)

```
